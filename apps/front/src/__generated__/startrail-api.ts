/**
 * Generated by orval v6.17.0 üç∫
 * Do not edit manually.
 * Startrail-API
 * Startrail-API Endpoint List
 * OpenAPI spec version: 0.0.1
 */
import {
  useQuery,
  useMutation
} from '@tanstack/react-query'
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from '@tanstack/react-query'
import { axiosInstance } from '../util/axios-instance';
import type { ErrorType } from '../util/axios-instance';
export type ExceptionTestControllerGetExceptionParams = {
/**
 * expected http code (https://github.com/nestjs/nest/blob/v8.3.1/packages/common/enums/http-status.enum.ts)
 */
httpCode: number;
/**
 * expected error message
 */
errorMessage: string;
};

export type TxControllerGetTxTxStatus = typeof TxControllerGetTxTxStatus[keyof typeof TxControllerGetTxTxStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TxControllerGetTxTxStatus = {
  pending: 'pending',
  success: 'success',
  failure: 'failure',
  mined: 'mined',
} as const;

export type TxControllerGetTxParams = {
/**
 * Query by transaction hash
 */
txHash?: string;
/**
 * The params are exclusive.
 */
txReceiptId?: number;
/**
 * Query by transaction status
 */
txStatus?: TxControllerGetTxTxStatus;
/**
 * Query by signer of meta-tx signature
 */
signingEOA?: string;
/**
 * Query by LicensedUserWallet the transaction was proxied through
 */
licensedUser?: string;
};

export type HealthControllerHealthCheck503Details = {[key: string]: {
  status?: string;
  [key: string]: string;
}};

export type HealthControllerHealthCheck503Error = {[key: string]: {
  status?: string;
  [key: string]: string;
}} | null;

export type HealthControllerHealthCheck503Info = {[key: string]: {
  status?: string;
  [key: string]: string;
}} | null;

export type HealthControllerHealthCheck503 = {
  status?: string;
  info?: HealthControllerHealthCheck503Info;
  error?: HealthControllerHealthCheck503Error;
  details?: HealthControllerHealthCheck503Details;
};

export type HealthControllerHealthCheck200Details = {[key: string]: {
  status?: string;
  [key: string]: string;
}};

export type HealthControllerHealthCheck200Error = {[key: string]: {
  status?: string;
  [key: string]: string;
}} | null;

export type HealthControllerHealthCheck200Info = {[key: string]: {
  status?: string;
  [key: string]: string;
}} | null;

export type HealthControllerHealthCheck200 = {
  status?: string;
  info?: HealthControllerHealthCheck200Info;
  error?: HealthControllerHealthCheck200Error;
  details?: HealthControllerHealthCheck200Details;
};

export type LicensedUserControllerGetLicensedUserWalletsParams = {
/**
 * Query by owner of LicensedUserWallet
 */
ownerEOA?: string;
/**
 * Query by LicensedUserWallet contract address
 */
walletAddress?: string;
/**
 * Limit the result set length to this number
 */
limit?: number;
/**
 * Order by Ascending (true) or Descending (false)
 */
orderAsc?: boolean;
};

export type SRRControllerGetSRRsParams = {
/**
 * Startrail Registry Record Token ID
 */
tokenId?: string;
/**
 * Query by collection contract address
 */
contractAddress?: string;
/**
 * Query by Owner EOA if Issuing LicensedUserWallet
 */
ownerEOA?: string;
/**
 * Query by Issuing LicensedUserWallet contract address
 */
issuerLUW?: string;
/**
 * The params are exclusive.
 */
txReceiptId?: number;
};

export interface CollectionTransferOwnershipDto {
  /** New address to transfer collection ownership too */
  newOwner: string;
}

export interface CreateCollectionDto {
  /** Collection name */
  name: string;
  /** Collection symbol */
  symbol: string;
  /** Create2 salt - salt used in Collection creation */
  salt?: string;
}

export interface GetFileMetadataRequest {
  /** An array of filepaths without bucket name */
  filepaths: string[];
  /** An optional array of booleans to determine the bucket for each filepath */
  isPrivateList: string[];
}

export interface GenerateSignedUrlsByPathsRequest {
  /** array of filepath without bucket name */
  filepaths: string[];
  /** An optional array of booleans to determine the bucket for each filepath */
  isPrivateList: string[];
}

export interface GenerateCertAttachmentFileSignedUrlsRequest {
  /** Array of name of the file to be saved under given cert ID in storage */
  filenames: string[];
  /** Enum for signedURL purpose, "read" to download, "write" to upload */
  action: string;
  /** An optional array of booleans to determine the bucket for each filepath */
  isPrivateList: string[];
}

/**
 * Enum for signedURL purpose, "read" to download, "write" to upload.
 */
export type GenerateSignedUrlsV2RequestAction = typeof GenerateSignedUrlsV2RequestAction[keyof typeof GenerateSignedUrlsV2RequestAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GenerateSignedUrlsV2RequestAction = {
  write: 'write',
  read: 'read',
} as const;

export interface FileInBucket {
  /** Filepath without bucket name. */
  filepath: string;
  /** Boolean to determine the bucket of the file. */
  isPrivate: boolean;
}

export interface GetFileMetadataV2Request {
  /** Array of file information. */
  files: FileInBucket[];
}

export interface GenerateSignedUrlsV2Request {
  /** Array of file information */
  files: FileInBucket[];
  /** Enum for signedURL purpose, "read" to download, "write" to upload. */
  action: GenerateSignedUrlsV2RequestAction;
}

export interface TxOverridePriceDto {
  /** Transactions that timeout will be resubmitted with this price if it's set. */
  overrideGasPriceGwei: number;
}

export interface TxConfig {
  /** Fixed id of 1 - only ever 1 row and it will always have id 1 */
  id: number;
  /** flag indicating the use of a fixed gas price */
  fixedGasPriceOn: boolean;
  /** gas price value for the default gas price in gwei */
  defaultGasPriceGwei: unknown;
  /** gas price value for the default maximum fee in gwei */
  defaultMaxFeePerGasPriceGwei: unknown;
  /** gas price value for the maximum priority fee in gwei */
  defaultMaxPriorityFeePerGasPriceGwei: unknown;
  /** time to wait for confirmation before transactions are resent with a higher bid */
  miningTimeoutSeconds: number;
  /** gas price value for the default gas price */
  oracleEndpoint: unknown;
  /** gas price level to set transaction processing speed */
  defaultGasLevel: unknown;
  /** flag indicating the usage of relaying admin signed transactions to a wrapping service */
  relayAdminTxByITX: boolean;
  /** flag indicating the usage of uploading metadata to ipfs */
  enableIpfs: boolean;
  /** flag indicating the usage of uploading file for contract terms and thumbnail to ipfs */
  enableIpfsForFile: boolean;
  /** flag enabling to use royalty - ERC2981 */
  enableRoyalty: boolean;
  /** flag indicating the usage of async transaction */
  asyncTxSend: boolean;
  /** gas price value for the default gas price */
  updatedAt: unknown;
}

/**
 * Default EthGasStation price level to use when dynamic prices is on and fixedGasPriceOn = false
 */
export type TxConfigDtoDefaultGasLevel = typeof TxConfigDtoDefaultGasLevel[keyof typeof TxConfigDtoDefaultGasLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TxConfigDtoDefaultGasLevel = {
  safelow: 'safelow',
  standard: 'standard',
  fast: 'fast',
  fastest: 'fastest',
} as const;

export interface TxConfigDto {
  /** Set to true to use fixed gas prices stored in the database.Set to false to use dynamic gas prices from EthGasStation. */
  fixedGasPriceOn: boolean;
  /** Gas price to submit transactions with when fixedGasPriceOn=true */
  defaultGasPriceGwei: number;
  /** Gas price to submit transactions max fee with when fixedGasPriceOn=true */
  defaultMaxFeePerGasPriceGwei: number;
  /** Gas price to submit transactions priority fee with when fixedGasPriceOn=true */
  defaultMaxPriorityFeePerGasPriceGwei: number;
  /** Resubmit pending transactions after they have been in the tx pool this many seconds */
  miningTimeoutSeconds: number;
  /** EthGasStation URL */
  oracleEndpoint: string;
  /** Default EthGasStation price level to use when dynamic prices is on and fixedGasPriceOn = false */
  defaultGasLevel: TxConfigDtoDefaultGasLevel;
  /** Feature flag enabling ITX relay to handle admin transactions */
  relayAdminTxByITX: boolean;
  /** Feature flag enabling to upload metadata to ipfs */
  enableIpfs: boolean;
  /** Feature flag enabling to upload file for contract terms and thumbnail to ipfs */
  enableIpfsForFile: boolean;
  /** Feature flag enabling to use royalty - ERC2981 */
  enableRoyalty: boolean;
  /** Feature flag enabling to send async transaction */
  asyncTxSend: boolean;
}

export type TxReceiptResponseDtoSigningEOA = { [key: string]: any };

export type TxReceiptResponseDtoHash = { [key: string]: any };

export interface TxReceiptResponseDto {
  txReceiptId: number;
  hash: TxReceiptResponseDtoHash;
  signingEOA: TxReceiptResponseDtoSigningEOA;
  txStatus: string;
  /** Transaction confirmed - a number of blocks have been mined since this one was mined */
  confirmed: boolean;
  errorReason: string;
  createdAt: string;
  updatedAt: string;
}

export interface GasInfo { [key: string]: any }

export interface GetCollectionResponseDto {
  /** Name of the collection. Will be the same as in metadata.name, but also stored on the contract */
  name: string;
  /** Symbol to identify the token  */
  symbol: string;
  /** Contract address of the collection contract. Will be visible on opensea. */
  contractAddress: string;
  /** Address of the owner of the collection. */
  ownerAddress: string;
  /** Collection Contract Metadata CID (TO BE REMOVED) */
  metadataCID: string;
  /** Collection created at */
  createdAt: string;
  /** Collection updated at */
  updatedAt: string;
}

export interface LicensedUserWallet { [key: string]: any }

export interface LicensedUserWalletRemoveOwnerDto {
  /** List of owners Ethereum addresses to remove */
  owners: string[];
  /** LUW Ethereum address */
  luwAddress: string;
}

export interface LicensedUserWalletAddOwnerDto {
  /** List of owners Ethereum addresses to add */
  owners: string[];
  /** LUW Ethereum address */
  luwAddress: string;
}

export interface LicensedUserWalletSetOriginalNameDto {
  /** LUW Ethereum address */
  luwAddress: string;
  /** Official name in original language */
  originalName: string;
}

export interface LicensedUserWalletSetEnglishNameDto {
  /** LUW Ethereum address */
  luwAddress: string;
  /** Official name in English */
  englishName: string;
}

/**
 * User type
 */
export type CreateLicensedUserWalletDtoUserType = typeof CreateLicensedUserWalletDtoUserType[keyof typeof CreateLicensedUserWalletDtoUserType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateLicensedUserWalletDtoUserType = {
  handler: 'handler',
  artist: 'artist',
} as const;

export interface CreateLicensedUserWalletDto {
  /** List of owners Ethereum addresses */
  owners: string[];
  /** Number of signatures required to approve a transaction */
  threshold: number;
  /** Official name in English */
  englishName: string;
  /** Official name in original language */
  originalName: string;
  /** User type */
  userType: CreateLicensedUserWalletDtoUserType;
  /** Create2 salt - a random salt is generated if none is given here */
  salt?: string;
}

export interface UpdateCollectionSRRDto {
  /** Issued by Primary Issuer flag */
  isPrimaryIssuer: boolean;
  /** Artist Ethereum Address */
  artistAddress: string;
}

/**
 * SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json
 */
export type CreateCollectionSRRDtoMetadata = { [key: string]: any };

export interface CreateCollectionSRRDto {
  /** Issued by Primary Issuer flag */
  isPrimaryIssuer: boolean;
  /** Artist Ethereum Address */
  artistAddress: string;
  /** SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json */
  metadata: CreateCollectionSRRDtoMetadata;
  /** SRR flag to disable standard ERC721 transfer methods */
  lockExternalTransfer: boolean;
  /** Recipient Ethereum Address */
  to: string;
}

export interface CheckERC2981RoyaltyResponse {
  /** SRR Royalty receiver, null if its ERC2981 is not activated or ineligible */
  royaltyReceiver: unknown;
  /** SRR royalty basis points, null if its ERC2981 is not activated or ineligible */
  royaltyBasisPoints: unknown;
}

/**
 * SRR Metadata (for draft SRR to check if metadata will apply ERC2981). This one is required if tokenId is not set
 */
export type CheckERC2981RoyaltyDtoMetadata = { [key: string]: any };

export interface CheckERC2981RoyaltyDto {
  /** Collection contract address. If this one is set, it will be utilized for the collection, otherwise, it will be applied for Startrail Registry. */
  contractAddress?: string;
  /** SRR Token ID (for already issued SRR). If this one is set, issuerAddress anb metadata will be ignored */
  tokenId?: string;
  /** SRR Metadata (for draft SRR to check if metadata will apply ERC2981). This one is required if tokenId is not set */
  metadata?: CheckERC2981RoyaltyDtoMetadata;
  /** Issuer Ethereum Address (for draft SRR). This one is required if tokenId is not set */
  issuerAddress?: string;
}

export interface SetLockExternalTranferDto {
  /** the flag to disable standard ERC721 transfer methods */
  flag: boolean;
}

export interface AddHistoryDto {
  /** Tokens to associate histories with */
  tokenIds: string[];
  /** History to associate tokens with */
  customHistoryIds: string[];
}

export interface CreateBatchTransferResponse {
  txReceiptId: number;
  batchId: number;
}

/**
 * Input values according to functionType
 */
export type GeneralizedBulkDtoData = { [key: string]: any };

export interface GeneralizedBulkDto {
  /** function type (createSRR, approveSRRByCommitment, transferFromWithProvenance) */
  functionType: string;
  /** Input values according to functionType */
  data: GeneralizedBulkDtoData;
}

export interface CreateGeneralizedBatchRequest {
  /** A JSON array of details of each transactions. */
  txs: GeneralizedBulkDto[];
}

/**
 * SRR Transfer Metadata conforming to the JSON schema registry-record-transfer-metadata.schema.json
 */
export type TransferFromWithProvenanceDtoMetadata = { [key: string]: any };

export interface TransferFromWithProvenanceDto {
  /** Address to transfer for ownership to. */
  to: string;
  /** SRR Transfer Metadata conforming to the JSON schema registry-record-transfer-metadata.schema.json */
  metadata: TransferFromWithProvenanceDtoMetadata;
  /** Intermediary flag used by startbahn to trigger a transaction. - defaults to false */
  isIntermediary: boolean;
}

export interface TransferSRRByRevealDto {
  /** Reveal hash the hash of which matches the commitment in the approveByCommitment */
  revealHash: string;
  /** Address to transfer for ownership to. */
  to: string;
  /** Intermediary flag used by startbahn to trigger a transaction. - defaults to false */
  isIntermediary: boolean;
}

/**
 * Nonce within the Channel (optional - will query blockchain for the next nonce)
 */
export type GetTypedDataDtoChannelNonce = { [key: string]: any };

/**
 * Nonce Channel to use (optional - defaults to 0)
 */
export type GetTypedDataDtoChannelId = { [key: string]: any };

/**
 * Request data for the meta transaction
 */
export type GetTypedDataDtoRequestData = { [key: string]: any };

export interface GetTypedDataDto {
  /** Request data for the meta transaction */
  requestData: GetTypedDataDtoRequestData;
  /** Nonce Channel to use (optional - defaults to 0) */
  channelId: GetTypedDataDtoChannelId;
  /** Nonce within the Channel (optional - will query blockchain for the next nonce) */
  channelNonce: GetTypedDataDtoChannelNonce;
  /** Address of licensed user wallet. If no datafield is set, it is regarded as tx from EOA */
  fromAddress: string;
}

/**
 * SRR Transfer Metadata conforming to the JSON schema registry-record-transfer-metadata.schema.json
 */
export type ApproveSRRByCommitmentDtoMetadata = { [key: string]: any };

export interface ApproveSRRByCommitmentDto {
  /** email to be used in the commit/reveal scheme. */
  preimage: string;
  /** single keccak256 hash of email to be used in the commit/reveal scheme. */
  revealHash: string;
  /** SRR Transfer Metadata conforming to the JSON schema registry-record-transfer-metadata.schema.json */
  metadata: ApproveSRRByCommitmentDtoMetadata;
}

/**
 * error message if it is emitted
 */
export type ConvertMetadataResponseMessage = { [key: string]: any };

/**
 * SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json
 */
export type ConvertMetadataResponseMetadata = { [key: string]: any };

export interface ConvertMetadataResponse {
  /** SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json */
  metadata: ConvertMetadataResponseMetadata;
  /** true if metadata is converted */
  isConverted: boolean;
  /** error message if it is emitted */
  message: ConvertMetadataResponseMessage;
}

/**
 * SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json
 */
export type ConvertMetadataDtoMetadata = { [key: string]: any };

export interface ConvertMetadataDto {
  /** SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json */
  metadata: ConvertMetadataDtoMetadata;
  /** artistName for metadata description */
  artistName: string;
  /** externalUrl */
  externalUrl: string;
  /** issuerName for metadata description */
  issuerName: string;
  /** tokenId by which SRR data is to be fetched to create metadata description */
  tokenId: string;
  /** collection address of the SRR */
  contractAddress: string;
}

export interface ConvertBatchMetadataRequestDto {
  /** SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json */
  metadataBatch: ConvertMetadataDto[];
}

export interface Object { [key: string]: any }

export interface UpdateSRRDto {
  /** Issued by Primary Issuer flag */
  isPrimaryIssuer: boolean;
  /** Artist Ethereum Address */
  artistAddress: string;
}

/**
 * Nonce within the Channel (optional - will query blockchain for the next nonce)
 */
export type GetTypedDataLuDtoChannelNonce = { [key: string]: any };

/**
 * Nonce Channel to use (optional - defaults to 0)
 */
export type GetTypedDataLuDtoChannelId = { [key: string]: any };

/**
 * Request data for the meta transaction
 */
export type GetTypedDataLuDtoRequestData = { [key: string]: any };

export interface GetTypedDataLuDto {
  /** Request data for the meta transaction */
  requestData: GetTypedDataLuDtoRequestData;
  /** Nonce Channel to use (optional - defaults to 0) */
  channelId: GetTypedDataLuDtoChannelId;
  /** Nonce within the Channel (optional - will query blockchain for the next nonce) */
  channelNonce: GetTypedDataLuDtoChannelNonce;
  /** Address of licensed user wallet */
  fromAddress: string;
}

/**
 * SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json
 */
export type CreateSRRDtoMetadata = { [key: string]: any };

export interface CreateSRRDto {
  /** Issued by Primary Issuer flag */
  isPrimaryIssuer: boolean;
  /** Artist Ethereum Address */
  artistAddress: string;
  /** SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json */
  metadata: CreateSRRDtoMetadata;
  /** SRR flag to disable standard ERC721 transfer methods */
  lockExternalTransfer: boolean;
  /** Recipient Ethereum Address */
  to: string;
}

export interface Srr { [key: string]: any }

export interface AddCustomHistoryTypeDto {
  /** Name of Custom History Type in lower case */
  historyTypeName: string;
}

/**
 * Custom History Metadata conforming to one of the custom-history-* JSON schemas. See startrail-common-js metadata-schemas/.
 */
export type UpdateCustomHistoryDtoMetadata = { [key: string]: any };

export interface UpdateCustomHistoryDto {
  /** Custom History Metadata conforming to one of the custom-history-* JSON schemas. See startrail-common-js metadata-schemas/. */
  metadata: UpdateCustomHistoryDtoMetadata;
}

export interface TxResponseDto {
  txReceiptId: number;
}

/**
 * Additional Data that is not directly part of the custom history entry, optional. if used will link Certs to the history and notify other subsystems about the provided data
 */
export type CreateCustomHistoryDtoAdditionalOffChainMetadata = { [key: string]: any };

/**
 * Custom History Metadata conforming to one of the custom-history-* JSON schemas. See startrail-common-js metadata-schemas/.
 */
export type CreateCustomHistoryDtoMetadata = { [key: string]: any };

export interface CreateCustomHistoryDto {
  /** Custom History Metadata conforming to one of the custom-history-* JSON schemas. See startrail-common-js metadata-schemas/. */
  metadata: CreateCustomHistoryDtoMetadata;
  /** Additional Data that is not directly part of the custom history entry, optional. if used will link Certs to the history and notify other subsystems about the provided data */
  additionalOffChainMetadata: CreateCustomHistoryDtoAdditionalOffChainMetadata;
}




// eslint-disable-next-line
  type SecondParameter<T extends (...args: any) => any> = T extends (
  config: any,
  args: infer P,
) => any
  ? P
  : never;

/**
 * Admin only route to create custom history as Metadata.
 * @summary Create custom history
 */
export const customHistoriesControllerCreateCustomHistory = (
    createCustomHistoryDto: CreateCustomHistoryDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/customHistories`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createCustomHistoryDto
    },
      options);
    }
  


export const getCustomHistoriesControllerCreateCustomHistoryMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customHistoriesControllerCreateCustomHistory>>, TError,{data: CreateCustomHistoryDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof customHistoriesControllerCreateCustomHistory>>, TError,{data: CreateCustomHistoryDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customHistoriesControllerCreateCustomHistory>>, {data: CreateCustomHistoryDto}> = (props) => {
          const {data} = props ?? {};

          return  customHistoriesControllerCreateCustomHistory(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CustomHistoriesControllerCreateCustomHistoryMutationResult = NonNullable<Awaited<ReturnType<typeof customHistoriesControllerCreateCustomHistory>>>
    export type CustomHistoriesControllerCreateCustomHistoryMutationBody = CreateCustomHistoryDto
    export type CustomHistoriesControllerCreateCustomHistoryMutationError = ErrorType<void>

    /**
 * @summary Create custom history
 */
export const useCustomHistoriesControllerCreateCustomHistory = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customHistoriesControllerCreateCustomHistory>>, TError,{data: CreateCustomHistoryDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getCustomHistoriesControllerCreateCustomHistoryMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Allow custom history metadata to be amended
 */
export const customHistoriesControllerUpdateCustomHistoryMetadata = (
    id: number,
    updateCustomHistoryDto: UpdateCustomHistoryDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/customHistories/${id}/metadata`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: updateCustomHistoryDto
    },
      options);
    }
  


export const getCustomHistoriesControllerUpdateCustomHistoryMetadataMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customHistoriesControllerUpdateCustomHistoryMetadata>>, TError,{id: number;data: UpdateCustomHistoryDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof customHistoriesControllerUpdateCustomHistoryMetadata>>, TError,{id: number;data: UpdateCustomHistoryDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customHistoriesControllerUpdateCustomHistoryMetadata>>, {id: number;data: UpdateCustomHistoryDto}> = (props) => {
          const {id,data} = props ?? {};

          return  customHistoriesControllerUpdateCustomHistoryMetadata(id,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CustomHistoriesControllerUpdateCustomHistoryMetadataMutationResult = NonNullable<Awaited<ReturnType<typeof customHistoriesControllerUpdateCustomHistoryMetadata>>>
    export type CustomHistoriesControllerUpdateCustomHistoryMetadataMutationBody = UpdateCustomHistoryDto
    export type CustomHistoriesControllerUpdateCustomHistoryMetadataMutationError = ErrorType<void>

    /**
 * @summary Allow custom history metadata to be amended
 */
export const useCustomHistoriesControllerUpdateCustomHistoryMetadata = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customHistoriesControllerUpdateCustomHistoryMetadata>>, TError,{id: number;data: UpdateCustomHistoryDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getCustomHistoriesControllerUpdateCustomHistoryMetadataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get JSON schema for the Custom History of Auction Metadata JSON.
 * @summary Get the Custom History of Auction metadata JSON schema file
 */
export const customHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchema = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<void>(
      {url: `/api/v1/customHistories/metadata/custom-history-of-auction-metadata.schema.json`, method: 'get', signal
    },
      options);
    }
  

export const getCustomHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchemaQueryKey = () => [`/api/v1/customHistories/metadata/custom-history-of-auction-metadata.schema.json`] as const;
  

    
export const getCustomHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchemaQueryOptions = <TData = Awaited<ReturnType<typeof customHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchema>>, TError = ErrorType<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof customHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchema>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof customHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchema>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCustomHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchemaQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof customHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchema>>> = ({ signal }) => customHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchema(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type CustomHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchemaQueryResult = NonNullable<Awaited<ReturnType<typeof customHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchema>>>
export type CustomHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchemaQueryError = ErrorType<unknown>

/**
 * @summary Get the Custom History of Auction metadata JSON schema file
 */
export const useCustomHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchema = <TData = Awaited<ReturnType<typeof customHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchema>>, TError = ErrorType<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof customHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchema>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getCustomHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchemaQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Admin only route to add custom history type.
 * @summary Add custom history type
 */
export const customHistoryControllerAddCustomHistoryType = (
    addCustomHistoryTypeDto: AddCustomHistoryTypeDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/customHistory/historyTypes`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: addCustomHistoryTypeDto
    },
      options);
    }
  


export const getCustomHistoryControllerAddCustomHistoryTypeMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customHistoryControllerAddCustomHistoryType>>, TError,{data: AddCustomHistoryTypeDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof customHistoryControllerAddCustomHistoryType>>, TError,{data: AddCustomHistoryTypeDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof customHistoryControllerAddCustomHistoryType>>, {data: AddCustomHistoryTypeDto}> = (props) => {
          const {data} = props ?? {};

          return  customHistoryControllerAddCustomHistoryType(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CustomHistoryControllerAddCustomHistoryTypeMutationResult = NonNullable<Awaited<ReturnType<typeof customHistoryControllerAddCustomHistoryType>>>
    export type CustomHistoryControllerAddCustomHistoryTypeMutationBody = AddCustomHistoryTypeDto
    export type CustomHistoryControllerAddCustomHistoryTypeMutationError = ErrorType<unknown>

    /**
 * @summary Add custom history type
 */
export const useCustomHistoryControllerAddCustomHistoryType = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof customHistoryControllerAddCustomHistoryType>>, TError,{data: AddCustomHistoryTypeDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getCustomHistoryControllerAddCustomHistoryTypeMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get a list of SRRs filtering by query parameters.
 * @summary Get a list of SRRs
 */
export const sRRControllerGetSRRs = (
    params?: SRRControllerGetSRRsParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<Srr[]>(
      {url: `/api/v1/srr`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getSRRControllerGetSRRsQueryKey = (params?: SRRControllerGetSRRsParams,) => [`/api/v1/srr`, ...(params ? [params]: [])] as const;
  

    
export const getSRRControllerGetSRRsQueryOptions = <TData = Awaited<ReturnType<typeof sRRControllerGetSRRs>>, TError = ErrorType<void>>(params?: SRRControllerGetSRRsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetSRRs>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetSRRs>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSRRControllerGetSRRsQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof sRRControllerGetSRRs>>> = ({ signal }) => sRRControllerGetSRRs(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type SRRControllerGetSRRsQueryResult = NonNullable<Awaited<ReturnType<typeof sRRControllerGetSRRs>>>
export type SRRControllerGetSRRsQueryError = ErrorType<void>

/**
 * @summary Get a list of SRRs
 */
export const useSRRControllerGetSRRs = <TData = Awaited<ReturnType<typeof sRRControllerGetSRRs>>, TError = ErrorType<void>>(
 params?: SRRControllerGetSRRsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetSRRs>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSRRControllerGetSRRsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Issue a new SRR on Startrail. Sends a transaction to StartrailRegistry.createSRR.
 * @summary Issue a new SRR
 */
export const sRRControllerCreateSRR = (
    createSRRDto: CreateSRRDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createSRRDto
    },
      options);
    }
  


export const getSRRControllerCreateSRRMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateSRR>>, TError,{data: CreateSRRDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateSRR>>, TError,{data: CreateSRRDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCreateSRR>>, {data: CreateSRRDto}> = (props) => {
          const {data} = props ?? {};

          return  sRRControllerCreateSRR(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCreateSRRMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCreateSRR>>>
    export type SRRControllerCreateSRRMutationBody = CreateSRRDto
    export type SRRControllerCreateSRRMutationError = ErrorType<void>

    /**
 * @summary Issue a new SRR
 */
export const useSRRControllerCreateSRR = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateSRR>>, TError,{data: CreateSRRDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCreateSRRMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Build typed data for an Issue SRR request
 */
export const sRRControllerCreateSRRTypedData = (
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getSRRControllerCreateSRRTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateSRRTypedData>>, TError,{data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateSRRTypedData>>, TError,{data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCreateSRRTypedData>>, {data: GetTypedDataLuDto}> = (props) => {
          const {data} = props ?? {};

          return  sRRControllerCreateSRRTypedData(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCreateSRRTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCreateSRRTypedData>>>
    export type SRRControllerCreateSRRTypedDataMutationBody = GetTypedDataLuDto
    export type SRRControllerCreateSRRTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for an Issue SRR request
 */
export const useSRRControllerCreateSRRTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateSRRTypedData>>, TError,{data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCreateSRRTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Update details of an SRR on Startrail. Sends a transaction to StartrailRegistry.updateSRR.
 * @summary Update details of an SRR
 */
export const sRRControllerUpdateSRR = (
    tokenId: string,
    updateSRRDto: UpdateSRRDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${tokenId}`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: updateSRRDto
    },
      options);
    }
  


export const getSRRControllerUpdateSRRMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerUpdateSRR>>, TError,{tokenId: string;data: UpdateSRRDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerUpdateSRR>>, TError,{tokenId: string;data: UpdateSRRDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerUpdateSRR>>, {tokenId: string;data: UpdateSRRDto}> = (props) => {
          const {tokenId,data} = props ?? {};

          return  sRRControllerUpdateSRR(tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerUpdateSRRMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerUpdateSRR>>>
    export type SRRControllerUpdateSRRMutationBody = UpdateSRRDto
    export type SRRControllerUpdateSRRMutationError = ErrorType<void>

    /**
 * @summary Update details of an SRR
 */
export const useSRRControllerUpdateSRR = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerUpdateSRR>>, TError,{tokenId: string;data: UpdateSRRDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerUpdateSRRMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Build typed data for an Update SRR request
 */
export const sRRControllerUpdateSRRTypedData = (
    tokenId: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${tokenId}/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getSRRControllerUpdateSRRTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerUpdateSRRTypedData>>, TError,{tokenId: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerUpdateSRRTypedData>>, TError,{tokenId: string;data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerUpdateSRRTypedData>>, {tokenId: string;data: GetTypedDataLuDto}> = (props) => {
          const {tokenId,data} = props ?? {};

          return  sRRControllerUpdateSRRTypedData(tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerUpdateSRRTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerUpdateSRRTypedData>>>
    export type SRRControllerUpdateSRRTypedDataMutationBody = GetTypedDataLuDto
    export type SRRControllerUpdateSRRTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for an Update SRR request
 */
export const useSRRControllerUpdateSRRTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerUpdateSRRTypedData>>, TError,{tokenId: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerUpdateSRRTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get metadata JSON for a given token.<br/>This is the ERC721 tokenURI().
 * @summary Get token metadata JSON
 */
export const sRRControllerGetMetadataJSONByTokenID = (
    tokenFile: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/${tokenFile}`, method: 'get', signal
    },
      options);
    }
  

export const getSRRControllerGetMetadataJSONByTokenIDQueryKey = (tokenFile: string,) => [`/api/v1/srr/metadata/${tokenFile}`] as const;
  

    
export const getSRRControllerGetMetadataJSONByTokenIDQueryOptions = <TData = Awaited<ReturnType<typeof sRRControllerGetMetadataJSONByTokenID>>, TError = ErrorType<unknown>>(tokenFile: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetMetadataJSONByTokenID>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetMetadataJSONByTokenID>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSRRControllerGetMetadataJSONByTokenIDQueryKey(tokenFile);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof sRRControllerGetMetadataJSONByTokenID>>> = ({ signal }) => sRRControllerGetMetadataJSONByTokenID(tokenFile, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(tokenFile), ...queryOptions}}

export type SRRControllerGetMetadataJSONByTokenIDQueryResult = NonNullable<Awaited<ReturnType<typeof sRRControllerGetMetadataJSONByTokenID>>>
export type SRRControllerGetMetadataJSONByTokenIDQueryError = ErrorType<unknown>

/**
 * @summary Get token metadata JSON
 */
export const useSRRControllerGetMetadataJSONByTokenID = <TData = Awaited<ReturnType<typeof sRRControllerGetMetadataJSONByTokenID>>, TError = ErrorType<unknown>>(
 tokenFile: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetMetadataJSONByTokenID>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSRRControllerGetMetadataJSONByTokenIDQueryOptions(tokenFile,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Update metadata JSON for a given token.<br/>This is the ERC721 tokenURI().
 * @summary Update token metadata JSON
 */
export const sRRControllerUpdateMetadata = (
    tokenFile: string,
    sRRControllerUpdateMetadataBody: Object,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/metadata/${tokenFile}`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: sRRControllerUpdateMetadataBody
    },
      options);
    }
  


export const getSRRControllerUpdateMetadataMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerUpdateMetadata>>, TError,{tokenFile: string;data: Object}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerUpdateMetadata>>, TError,{tokenFile: string;data: Object}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerUpdateMetadata>>, {tokenFile: string;data: Object}> = (props) => {
          const {tokenFile,data} = props ?? {};

          return  sRRControllerUpdateMetadata(tokenFile,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerUpdateMetadataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerUpdateMetadata>>>
    export type SRRControllerUpdateMetadataMutationBody = Object
    export type SRRControllerUpdateMetadataMutationError = ErrorType<void>

    /**
 * @summary Update token metadata JSON
 */
export const useSRRControllerUpdateMetadata = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerUpdateMetadata>>, TError,{tokenFile: string;data: Object}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerUpdateMetadataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Build typed data for an Update Metadata request
 */
export const sRRControllerUpdateMetadataTypedData = (
    tokenFile: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/${tokenFile}/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getSRRControllerUpdateMetadataTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerUpdateMetadataTypedData>>, TError,{tokenFile: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerUpdateMetadataTypedData>>, TError,{tokenFile: string;data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerUpdateMetadataTypedData>>, {tokenFile: string;data: GetTypedDataLuDto}> = (props) => {
          const {tokenFile,data} = props ?? {};

          return  sRRControllerUpdateMetadataTypedData(tokenFile,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerUpdateMetadataTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerUpdateMetadataTypedData>>>
    export type SRRControllerUpdateMetadataTypedDataMutationBody = GetTypedDataLuDto
    export type SRRControllerUpdateMetadataTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for an Update Metadata request
 */
export const useSRRControllerUpdateMetadataTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerUpdateMetadataTypedData>>, TError,{tokenFile: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerUpdateMetadataTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get the V1 JSON schema for the SRR Metadata JSON.
 * @summary Get the V1 SRR metadata JSON schema file
 */
export const sRRControllerGetMetadataJSONSchemaV1 = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/registry-record-metadata.schema.json`, method: 'get', signal
    },
      options);
    }
  

export const getSRRControllerGetMetadataJSONSchemaV1QueryKey = () => [`/api/v1/srr/metadata/registry-record-metadata.schema.json`] as const;
  

    
export const getSRRControllerGetMetadataJSONSchemaV1QueryOptions = <TData = Awaited<ReturnType<typeof sRRControllerGetMetadataJSONSchemaV1>>, TError = ErrorType<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetMetadataJSONSchemaV1>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetMetadataJSONSchemaV1>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSRRControllerGetMetadataJSONSchemaV1QueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof sRRControllerGetMetadataJSONSchemaV1>>> = ({ signal }) => sRRControllerGetMetadataJSONSchemaV1(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type SRRControllerGetMetadataJSONSchemaV1QueryResult = NonNullable<Awaited<ReturnType<typeof sRRControllerGetMetadataJSONSchemaV1>>>
export type SRRControllerGetMetadataJSONSchemaV1QueryError = ErrorType<unknown>

/**
 * @summary Get the V1 SRR metadata JSON schema file
 */
export const useSRRControllerGetMetadataJSONSchemaV1 = <TData = Awaited<ReturnType<typeof sRRControllerGetMetadataJSONSchemaV1>>, TError = ErrorType<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetMetadataJSONSchemaV1>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSRRControllerGetMetadataJSONSchemaV1QueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Get the V1 JSON schema for the SRR Transfer Metadata JSON.
 * @summary Get the V1 SRR Transfer metadata JSON schema file
 */
export const sRRControllerGetTransferMetadataJSONSchemaV1 = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/registry-record-transfer-metadata.schema.json`, method: 'get', signal
    },
      options);
    }
  

export const getSRRControllerGetTransferMetadataJSONSchemaV1QueryKey = () => [`/api/v1/srr/metadata/registry-record-transfer-metadata.schema.json`] as const;
  

    
export const getSRRControllerGetTransferMetadataJSONSchemaV1QueryOptions = <TData = Awaited<ReturnType<typeof sRRControllerGetTransferMetadataJSONSchemaV1>>, TError = ErrorType<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetTransferMetadataJSONSchemaV1>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetTransferMetadataJSONSchemaV1>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSRRControllerGetTransferMetadataJSONSchemaV1QueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof sRRControllerGetTransferMetadataJSONSchemaV1>>> = ({ signal }) => sRRControllerGetTransferMetadataJSONSchemaV1(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type SRRControllerGetTransferMetadataJSONSchemaV1QueryResult = NonNullable<Awaited<ReturnType<typeof sRRControllerGetTransferMetadataJSONSchemaV1>>>
export type SRRControllerGetTransferMetadataJSONSchemaV1QueryError = ErrorType<unknown>

/**
 * @summary Get the V1 SRR Transfer metadata JSON schema file
 */
export const useSRRControllerGetTransferMetadataJSONSchemaV1 = <TData = Awaited<ReturnType<typeof sRRControllerGetTransferMetadataJSONSchemaV1>>, TError = ErrorType<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetTransferMetadataJSONSchemaV1>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSRRControllerGetTransferMetadataJSONSchemaV1QueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Get Metadata History for an SRR.
 * @summary Get the all metadata records that have been set on an SRR from issuance to now
 */
export const sRRControllerGetMetadataHistory = (
    tokenId: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/${tokenId}/history`, method: 'get', signal
    },
      options);
    }
  

export const getSRRControllerGetMetadataHistoryQueryKey = (tokenId: string,) => [`/api/v1/srr/metadata/${tokenId}/history`] as const;
  

    
export const getSRRControllerGetMetadataHistoryQueryOptions = <TData = Awaited<ReturnType<typeof sRRControllerGetMetadataHistory>>, TError = ErrorType<unknown>>(tokenId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetMetadataHistory>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetMetadataHistory>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSRRControllerGetMetadataHistoryQueryKey(tokenId);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof sRRControllerGetMetadataHistory>>> = ({ signal }) => sRRControllerGetMetadataHistory(tokenId, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(tokenId), ...queryOptions}}

export type SRRControllerGetMetadataHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof sRRControllerGetMetadataHistory>>>
export type SRRControllerGetMetadataHistoryQueryError = ErrorType<unknown>

/**
 * @summary Get the all metadata records that have been set on an SRR from issuance to now
 */
export const useSRRControllerGetMetadataHistory = <TData = Awaited<ReturnType<typeof sRRControllerGetMetadataHistory>>, TError = ErrorType<unknown>>(
 tokenId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetMetadataHistory>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSRRControllerGetMetadataHistoryQueryOptions(tokenId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Metadata JSON is converted to the latest version according to the version schema
 * @summary Metadata JSON is converted to the latest version according to the version schema
 */
export const sRRControllerConvertMetadata = (
    convertBatchMetadataRequestDto: ConvertBatchMetadataRequestDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<ConvertMetadataResponse[]>(
      {url: `/api/v1/srr/metadata/convert`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: convertBatchMetadataRequestDto
    },
      options);
    }
  


export const getSRRControllerConvertMetadataMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerConvertMetadata>>, TError,{data: ConvertBatchMetadataRequestDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerConvertMetadata>>, TError,{data: ConvertBatchMetadataRequestDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerConvertMetadata>>, {data: ConvertBatchMetadataRequestDto}> = (props) => {
          const {data} = props ?? {};

          return  sRRControllerConvertMetadata(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerConvertMetadataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerConvertMetadata>>>
    export type SRRControllerConvertMetadataMutationBody = ConvertBatchMetadataRequestDto
    export type SRRControllerConvertMetadataMutationError = ErrorType<void>

    /**
 * @summary Metadata JSON is converted to the latest version according to the version schema
 */
export const useSRRControllerConvertMetadata = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerConvertMetadata>>, TError,{data: ConvertBatchMetadataRequestDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerConvertMetadataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Approve transfer by secret string to be used in a commit/reveal scheme where a double hash of the secret is used on commit / approval and a single hash is used on reveal / transfer. 
 * @summary Approve an SRR transfer by secret commitment
 */
export const sRRControllerApproveByCommitment = (
    tokenId: string,
    approveSRRByCommitmentDto: ApproveSRRByCommitmentDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${tokenId}/approveByCommitment`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: approveSRRByCommitmentDto
    },
      options);
    }
  


export const getSRRControllerApproveByCommitmentMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerApproveByCommitment>>, TError,{tokenId: string;data: ApproveSRRByCommitmentDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerApproveByCommitment>>, TError,{tokenId: string;data: ApproveSRRByCommitmentDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerApproveByCommitment>>, {tokenId: string;data: ApproveSRRByCommitmentDto}> = (props) => {
          const {tokenId,data} = props ?? {};

          return  sRRControllerApproveByCommitment(tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerApproveByCommitmentMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerApproveByCommitment>>>
    export type SRRControllerApproveByCommitmentMutationBody = ApproveSRRByCommitmentDto
    export type SRRControllerApproveByCommitmentMutationError = ErrorType<void>

    /**
 * @summary Approve an SRR transfer by secret commitment
 */
export const useSRRControllerApproveByCommitment = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerApproveByCommitment>>, TError,{tokenId: string;data: ApproveSRRByCommitmentDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerApproveByCommitmentMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Cancels an approval set by /approveByCommitment
 * @summary Cancel a prior approveByCommitment
 */
export const sRRControllerCancelApproved = (
    tokenId: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${tokenId}/approveByCommitment`, method: 'delete'
    },
      options);
    }
  


export const getSRRControllerCancelApprovedMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCancelApproved>>, TError,{tokenId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCancelApproved>>, TError,{tokenId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCancelApproved>>, {tokenId: string}> = (props) => {
          const {tokenId} = props ?? {};

          return  sRRControllerCancelApproved(tokenId,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCancelApprovedMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCancelApproved>>>
    
    export type SRRControllerCancelApprovedMutationError = ErrorType<void>

    /**
 * @summary Cancel a prior approveByCommitment
 */
export const useSRRControllerCancelApproved = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCancelApproved>>, TError,{tokenId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCancelApprovedMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Build typed data for an approve by commitment request
 */
export const sRRControllerApproveByCommitmentTypedData = (
    tokenId: string,
    getTypedDataDto: GetTypedDataDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${tokenId}/approveByCommitment/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataDto
    },
      options);
    }
  


export const getSRRControllerApproveByCommitmentTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerApproveByCommitmentTypedData>>, TError,{tokenId: string;data: GetTypedDataDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerApproveByCommitmentTypedData>>, TError,{tokenId: string;data: GetTypedDataDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerApproveByCommitmentTypedData>>, {tokenId: string;data: GetTypedDataDto}> = (props) => {
          const {tokenId,data} = props ?? {};

          return  sRRControllerApproveByCommitmentTypedData(tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerApproveByCommitmentTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerApproveByCommitmentTypedData>>>
    export type SRRControllerApproveByCommitmentTypedDataMutationBody = GetTypedDataDto
    export type SRRControllerApproveByCommitmentTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for an approve by commitment request
 */
export const useSRRControllerApproveByCommitmentTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerApproveByCommitmentTypedData>>, TError,{tokenId: string;data: GetTypedDataDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerApproveByCommitmentTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Build typed data for a cancel approval request
 */
export const sRRControllerCancelApprovedTypedData = (
    tokenId: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${tokenId}/approveByCommitment/typedData`, method: 'delete',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getSRRControllerCancelApprovedTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCancelApprovedTypedData>>, TError,{tokenId: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCancelApprovedTypedData>>, TError,{tokenId: string;data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCancelApprovedTypedData>>, {tokenId: string;data: GetTypedDataLuDto}> = (props) => {
          const {tokenId,data} = props ?? {};

          return  sRRControllerCancelApprovedTypedData(tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCancelApprovedTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCancelApprovedTypedData>>>
    export type SRRControllerCancelApprovedTypedDataMutationBody = GetTypedDataLuDto
    export type SRRControllerCancelApprovedTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for a cancel approval request
 */
export const useSRRControllerCancelApprovedTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCancelApprovedTypedData>>, TError,{tokenId: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCancelApprovedTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Transfer SRR to a new owner providing a reveal hash, the hash of matches the commitment given in the approval stage. 
 * @summary Transfer SRR by reveal.
 */
export const sRRControllerTransferByReveal = (
    tokenId: string,
    transferSRRByRevealDto: TransferSRRByRevealDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${tokenId}/transferByReveal`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: transferSRRByRevealDto
    },
      options);
    }
  


export const getSRRControllerTransferByRevealMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerTransferByReveal>>, TError,{tokenId: string;data: TransferSRRByRevealDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerTransferByReveal>>, TError,{tokenId: string;data: TransferSRRByRevealDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerTransferByReveal>>, {tokenId: string;data: TransferSRRByRevealDto}> = (props) => {
          const {tokenId,data} = props ?? {};

          return  sRRControllerTransferByReveal(tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerTransferByRevealMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerTransferByReveal>>>
    export type SRRControllerTransferByRevealMutationBody = TransferSRRByRevealDto
    export type SRRControllerTransferByRevealMutationError = ErrorType<unknown>

    /**
 * @summary Transfer SRR by reveal.
 */
export const useSRRControllerTransferByReveal = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerTransferByReveal>>, TError,{tokenId: string;data: TransferSRRByRevealDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerTransferByRevealMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Transfer SRR to new owner calling the transferFromWithProvenance function directly as a meta-tx
 * @summary Transfer SRR to new owner
 */
export const sRRControllerTransferFromWithProvenance = (
    tokenId: string,
    transferFromWithProvenanceDto: TransferFromWithProvenanceDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${tokenId}/transferFromWithProvenance`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: transferFromWithProvenanceDto
    },
      options);
    }
  


export const getSRRControllerTransferFromWithProvenanceMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerTransferFromWithProvenance>>, TError,{tokenId: string;data: TransferFromWithProvenanceDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerTransferFromWithProvenance>>, TError,{tokenId: string;data: TransferFromWithProvenanceDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerTransferFromWithProvenance>>, {tokenId: string;data: TransferFromWithProvenanceDto}> = (props) => {
          const {tokenId,data} = props ?? {};

          return  sRRControllerTransferFromWithProvenance(tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerTransferFromWithProvenanceMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerTransferFromWithProvenance>>>
    export type SRRControllerTransferFromWithProvenanceMutationBody = TransferFromWithProvenanceDto
    export type SRRControllerTransferFromWithProvenanceMutationError = ErrorType<void>

    /**
 * @summary Transfer SRR to new owner
 */
export const useSRRControllerTransferFromWithProvenance = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerTransferFromWithProvenance>>, TError,{tokenId: string;data: TransferFromWithProvenanceDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerTransferFromWithProvenanceMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Build typed data for an safe transfer from request
 */
export const sRRControllerSafeTransferFromTypedData = (
    tokenId: string,
    getTypedDataDto: GetTypedDataDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${tokenId}/transferFromWithProvenance/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataDto
    },
      options);
    }
  


export const getSRRControllerSafeTransferFromTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerSafeTransferFromTypedData>>, TError,{tokenId: string;data: GetTypedDataDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerSafeTransferFromTypedData>>, TError,{tokenId: string;data: GetTypedDataDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerSafeTransferFromTypedData>>, {tokenId: string;data: GetTypedDataDto}> = (props) => {
          const {tokenId,data} = props ?? {};

          return  sRRControllerSafeTransferFromTypedData(tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerSafeTransferFromTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerSafeTransferFromTypedData>>>
    export type SRRControllerSafeTransferFromTypedDataMutationBody = GetTypedDataDto
    export type SRRControllerSafeTransferFromTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for an safe transfer from request
 */
export const useSRRControllerSafeTransferFromTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerSafeTransferFromTypedData>>, TError,{tokenId: string;data: GetTypedDataDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerSafeTransferFromTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * A Generalized Batch endpoint
 * @summary A Generalized Batch endpoint
 */
export const sRRControllerCreateAndSendBatch = (
    createGeneralizedBatchRequest: CreateGeneralizedBatchRequest,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<CreateBatchTransferResponse>(
      {url: `/api/v1/srr/bulk`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createGeneralizedBatchRequest
    },
      options);
    }
  


export const getSRRControllerCreateAndSendBatchMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateAndSendBatch>>, TError,{data: CreateGeneralizedBatchRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateAndSendBatch>>, TError,{data: CreateGeneralizedBatchRequest}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCreateAndSendBatch>>, {data: CreateGeneralizedBatchRequest}> = (props) => {
          const {data} = props ?? {};

          return  sRRControllerCreateAndSendBatch(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCreateAndSendBatchMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCreateAndSendBatch>>>
    export type SRRControllerCreateAndSendBatchMutationBody = CreateGeneralizedBatchRequest
    export type SRRControllerCreateAndSendBatchMutationError = ErrorType<void>

    /**
 * @summary A Generalized Batch endpoint
 */
export const useSRRControllerCreateAndSendBatch = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateAndSendBatch>>, TError,{data: CreateGeneralizedBatchRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCreateAndSendBatchMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Build a typed data for a generalized bulk request.<br/>Return a MerkleRoot of a tree of generalized bulk leaf hashes. This root is to be signed by the sender.<br/>
 * @summary Build a typed data for a generalized bulk request
 */
export const sRRControllerCreateAndSendBatchTypedData = (
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/bulk/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getSRRControllerCreateAndSendBatchTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateAndSendBatchTypedData>>, TError,{data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateAndSendBatchTypedData>>, TError,{data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCreateAndSendBatchTypedData>>, {data: GetTypedDataLuDto}> = (props) => {
          const {data} = props ?? {};

          return  sRRControllerCreateAndSendBatchTypedData(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCreateAndSendBatchTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCreateAndSendBatchTypedData>>>
    export type SRRControllerCreateAndSendBatchTypedDataMutationBody = GetTypedDataLuDto
    export type SRRControllerCreateAndSendBatchTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build a typed data for a generalized bulk request
 */
export const useSRRControllerCreateAndSendBatchTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateAndSendBatchTypedData>>, TError,{data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCreateAndSendBatchTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get details of a generalized bulk given the batch id
 * @summary Get details of a generalized bulk
 */
export const sRRControllerGetBatch = (
    batchId: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/bulk/${batchId}`, method: 'get', signal
    },
      options);
    }
  

export const getSRRControllerGetBatchQueryKey = (batchId: number,) => [`/api/v1/srr/bulk/${batchId}`] as const;
  

    
export const getSRRControllerGetBatchQueryOptions = <TData = Awaited<ReturnType<typeof sRRControllerGetBatch>>, TError = ErrorType<unknown>>(batchId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetBatch>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetBatch>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSRRControllerGetBatchQueryKey(batchId);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof sRRControllerGetBatch>>> = ({ signal }) => sRRControllerGetBatch(batchId, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(batchId), ...queryOptions}}

export type SRRControllerGetBatchQueryResult = NonNullable<Awaited<ReturnType<typeof sRRControllerGetBatch>>>
export type SRRControllerGetBatchQueryError = ErrorType<unknown>

/**
 * @summary Get details of a generalized bulk
 */
export const useSRRControllerGetBatch = <TData = Awaited<ReturnType<typeof sRRControllerGetBatch>>, TError = ErrorType<unknown>>(
 batchId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetBatch>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSRRControllerGetBatchQueryOptions(batchId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Admin only route that can pause the generalized bulk queue.
 * @summary Pause processing of generalized bulk queue
 */
export const sRRControllerPauseGeneralizedBulkQueue = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/bulk/pause`, method: 'put'
    },
      options);
    }
  


export const getSRRControllerPauseGeneralizedBulkQueueMutationOptions = <TError = ErrorType<unknown>,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerPauseGeneralizedBulkQueue>>, TError,TVariables, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerPauseGeneralizedBulkQueue>>, TError,TVariables, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerPauseGeneralizedBulkQueue>>, TVariables> = () => {
          

          return  sRRControllerPauseGeneralizedBulkQueue(requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerPauseGeneralizedBulkQueueMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerPauseGeneralizedBulkQueue>>>
    
    export type SRRControllerPauseGeneralizedBulkQueueMutationError = ErrorType<unknown>

    /**
 * @summary Pause processing of generalized bulk queue
 */
export const useSRRControllerPauseGeneralizedBulkQueue = <TError = ErrorType<unknown>,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerPauseGeneralizedBulkQueue>>, TError,TVariables, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerPauseGeneralizedBulkQueueMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Admin only route that can resume the generalized bulk queue after a pause.
 * @summary Resume processing of generalized bulk queue
 */
export const sRRControllerResumeGeneralizedBulkQueue = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/bulk/resume`, method: 'put'
    },
      options);
    }
  


export const getSRRControllerResumeGeneralizedBulkQueueMutationOptions = <TError = ErrorType<unknown>,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerResumeGeneralizedBulkQueue>>, TError,TVariables, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerResumeGeneralizedBulkQueue>>, TError,TVariables, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerResumeGeneralizedBulkQueue>>, TVariables> = () => {
          

          return  sRRControllerResumeGeneralizedBulkQueue(requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerResumeGeneralizedBulkQueueMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerResumeGeneralizedBulkQueue>>>
    
    export type SRRControllerResumeGeneralizedBulkQueueMutationError = ErrorType<unknown>

    /**
 * @summary Resume processing of generalized bulk queue
 */
export const useSRRControllerResumeGeneralizedBulkQueue = <TError = ErrorType<unknown>,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerResumeGeneralizedBulkQueue>>, TError,TVariables, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerResumeGeneralizedBulkQueueMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Build typed data for for associating SRRs with existing custom histories
 * @summary Build typed data for for associating custom histories
 */
export const sRRControllerAddHistoryTypedData = (
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void | TxResponseDto>(
      {url: `/api/v1/srr/history/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getSRRControllerAddHistoryTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerAddHistoryTypedData>>, TError,{data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerAddHistoryTypedData>>, TError,{data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerAddHistoryTypedData>>, {data: GetTypedDataLuDto}> = (props) => {
          const {data} = props ?? {};

          return  sRRControllerAddHistoryTypedData(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerAddHistoryTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerAddHistoryTypedData>>>
    export type SRRControllerAddHistoryTypedDataMutationBody = GetTypedDataLuDto
    export type SRRControllerAddHistoryTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for for associating custom histories
 */
export const useSRRControllerAddHistoryTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerAddHistoryTypedData>>, TError,{data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerAddHistoryTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Associate SRRs with existing custom histories
 * @summary Associate SRRs with existing custom histories
 */
export const sRRControllerAddHistory = (
    addHistoryDto: AddHistoryDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/history`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: addHistoryDto
    },
      options);
    }
  


export const getSRRControllerAddHistoryMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerAddHistory>>, TError,{data: AddHistoryDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerAddHistory>>, TError,{data: AddHistoryDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerAddHistory>>, {data: AddHistoryDto}> = (props) => {
          const {data} = props ?? {};

          return  sRRControllerAddHistory(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerAddHistoryMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerAddHistory>>>
    export type SRRControllerAddHistoryMutationBody = AddHistoryDto
    export type SRRControllerAddHistoryMutationError = ErrorType<void>

    /**
 * @summary Associate SRRs with existing custom histories
 */
export const useSRRControllerAddHistory = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerAddHistory>>, TError,{data: AddHistoryDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerAddHistoryMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Disable/Enable standard ERC721 transfer methods
 * @summary Disable/Enable standard ERC721 transfer methods
 */
export const sRRControllerSetLockExternalTransfer = (
    tokenId: string,
    setLockExternalTranferDto: SetLockExternalTranferDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${tokenId}/lockExternalTransfer`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: setLockExternalTranferDto
    },
      options);
    }
  


export const getSRRControllerSetLockExternalTransferMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerSetLockExternalTransfer>>, TError,{tokenId: string;data: SetLockExternalTranferDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerSetLockExternalTransfer>>, TError,{tokenId: string;data: SetLockExternalTranferDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerSetLockExternalTransfer>>, {tokenId: string;data: SetLockExternalTranferDto}> = (props) => {
          const {tokenId,data} = props ?? {};

          return  sRRControllerSetLockExternalTransfer(tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerSetLockExternalTransferMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerSetLockExternalTransfer>>>
    export type SRRControllerSetLockExternalTransferMutationBody = SetLockExternalTranferDto
    export type SRRControllerSetLockExternalTransferMutationError = ErrorType<void>

    /**
 * @summary Disable/Enable standard ERC721 transfer methods
 */
export const useSRRControllerSetLockExternalTransfer = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerSetLockExternalTransfer>>, TError,{tokenId: string;data: SetLockExternalTranferDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerSetLockExternalTransferMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Build typed data for disable/enable standard ERC721 transfer methods
 */
export const sRRControllerSetLockExternalTransferTypedData = (
    tokenId: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${tokenId}/lockExternalTransfer/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getSRRControllerSetLockExternalTransferTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerSetLockExternalTransferTypedData>>, TError,{tokenId: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerSetLockExternalTransferTypedData>>, TError,{tokenId: string;data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerSetLockExternalTransferTypedData>>, {tokenId: string;data: GetTypedDataLuDto}> = (props) => {
          const {tokenId,data} = props ?? {};

          return  sRRControllerSetLockExternalTransferTypedData(tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerSetLockExternalTransferTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerSetLockExternalTransferTypedData>>>
    export type SRRControllerSetLockExternalTransferTypedDataMutationBody = GetTypedDataLuDto
    export type SRRControllerSetLockExternalTransferTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for disable/enable standard ERC721 transfer methods
 */
export const useSRRControllerSetLockExternalTransferTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerSetLockExternalTransferTypedData>>, TError,{tokenId: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerSetLockExternalTransferTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Startrail Registry and Collection: ERC2981 eligibility checker
 */
export const sRRControllerCheckERC2981Royalty = (
    checkERC2981RoyaltyDto: CheckERC2981RoyaltyDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<CheckERC2981RoyaltyResponse>(
      {url: `/api/v1/srr/erc2981/checker`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: checkERC2981RoyaltyDto
    },
      options);
    }
  


export const getSRRControllerCheckERC2981RoyaltyMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCheckERC2981Royalty>>, TError,{data: CheckERC2981RoyaltyDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCheckERC2981Royalty>>, TError,{data: CheckERC2981RoyaltyDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCheckERC2981Royalty>>, {data: CheckERC2981RoyaltyDto}> = (props) => {
          const {data} = props ?? {};

          return  sRRControllerCheckERC2981Royalty(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCheckERC2981RoyaltyMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCheckERC2981Royalty>>>
    export type SRRControllerCheckERC2981RoyaltyMutationBody = CheckERC2981RoyaltyDto
    export type SRRControllerCheckERC2981RoyaltyMutationError = ErrorType<unknown>

    /**
 * @summary Startrail Registry and Collection: ERC2981 eligibility checker
 */
export const useSRRControllerCheckERC2981Royalty = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCheckERC2981Royalty>>, TError,{data: CheckERC2981RoyaltyDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCheckERC2981RoyaltyMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Create a new SRR to a collection
 * @summary Create a new SRR to a collection
 */
export const sRRControllerCreateCollectionSRR = (
    contractAddress: string,
    createCollectionSRRDto: CreateCollectionSRRDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createCollectionSRRDto
    },
      options);
    }
  


export const getSRRControllerCreateCollectionSRRMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateCollectionSRR>>, TError,{contractAddress: string;data: CreateCollectionSRRDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateCollectionSRR>>, TError,{contractAddress: string;data: CreateCollectionSRRDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCreateCollectionSRR>>, {contractAddress: string;data: CreateCollectionSRRDto}> = (props) => {
          const {contractAddress,data} = props ?? {};

          return  sRRControllerCreateCollectionSRR(contractAddress,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCreateCollectionSRRMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCreateCollectionSRR>>>
    export type SRRControllerCreateCollectionSRRMutationBody = CreateCollectionSRRDto
    export type SRRControllerCreateCollectionSRRMutationError = ErrorType<void>

    /**
 * @summary Create a new SRR to a collection
 */
export const useSRRControllerCreateCollectionSRR = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateCollectionSRR>>, TError,{contractAddress: string;data: CreateCollectionSRRDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCreateCollectionSRRMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Build typed data for collection create srr
 */
export const sRRControllerCreateCollectionSRRTypeData = (
    contractAddress: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${contractAddress}/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getSRRControllerCreateCollectionSRRTypeDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateCollectionSRRTypeData>>, TError,{contractAddress: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateCollectionSRRTypeData>>, TError,{contractAddress: string;data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCreateCollectionSRRTypeData>>, {contractAddress: string;data: GetTypedDataLuDto}> = (props) => {
          const {contractAddress,data} = props ?? {};

          return  sRRControllerCreateCollectionSRRTypeData(contractAddress,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCreateCollectionSRRTypeDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCreateCollectionSRRTypeData>>>
    export type SRRControllerCreateCollectionSRRTypeDataMutationBody = GetTypedDataLuDto
    export type SRRControllerCreateCollectionSRRTypeDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for collection create srr
 */
export const useSRRControllerCreateCollectionSRRTypeData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCreateCollectionSRRTypeData>>, TError,{contractAddress: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCreateCollectionSRRTypeDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get collection metadata JSON for a given token.<br/>This is the ERC721 tokenURI().
 * @summary Get token metadata JSON
 */
export const sRRControllerGetCollectionMetadataJSONByTokenID = (
    contractAddress: string,
    tokenFile: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/${contractAddress}/${tokenFile}`, method: 'get', signal
    },
      options);
    }
  

export const getSRRControllerGetCollectionMetadataJSONByTokenIDQueryKey = (contractAddress: string,
    tokenFile: string,) => [`/api/v1/srr/metadata/${contractAddress}/${tokenFile}`] as const;
  

    
export const getSRRControllerGetCollectionMetadataJSONByTokenIDQueryOptions = <TData = Awaited<ReturnType<typeof sRRControllerGetCollectionMetadataJSONByTokenID>>, TError = ErrorType<unknown>>(contractAddress: string,
    tokenFile: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetCollectionMetadataJSONByTokenID>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetCollectionMetadataJSONByTokenID>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSRRControllerGetCollectionMetadataJSONByTokenIDQueryKey(contractAddress,tokenFile);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof sRRControllerGetCollectionMetadataJSONByTokenID>>> = ({ signal }) => sRRControllerGetCollectionMetadataJSONByTokenID(contractAddress,tokenFile, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(contractAddress && tokenFile), ...queryOptions}}

export type SRRControllerGetCollectionMetadataJSONByTokenIDQueryResult = NonNullable<Awaited<ReturnType<typeof sRRControllerGetCollectionMetadataJSONByTokenID>>>
export type SRRControllerGetCollectionMetadataJSONByTokenIDQueryError = ErrorType<unknown>

/**
 * @summary Get token metadata JSON
 */
export const useSRRControllerGetCollectionMetadataJSONByTokenID = <TData = Awaited<ReturnType<typeof sRRControllerGetCollectionMetadataJSONByTokenID>>, TError = ErrorType<unknown>>(
 contractAddress: string,
    tokenFile: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerGetCollectionMetadataJSONByTokenID>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSRRControllerGetCollectionMetadataJSONByTokenIDQueryOptions(contractAddress,tokenFile,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Update metadata JSON for a given token from a collection contract.<br/>This is the ERC721 tokenURI().
 * @summary Update token metadata JSON from a collection contract
 */
export const sRRControllerCollectionSRRMetadataUpdate = (
    contractAddress: string,
    tokenFile: string,
    sRRControllerCollectionSRRMetadataUpdateBody: Object,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/metadata/${contractAddress}/${tokenFile}`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: sRRControllerCollectionSRRMetadataUpdateBody
    },
      options);
    }
  


export const getSRRControllerCollectionSRRMetadataUpdateMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionSRRMetadataUpdate>>, TError,{contractAddress: string;tokenFile: string;data: Object}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionSRRMetadataUpdate>>, TError,{contractAddress: string;tokenFile: string;data: Object}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionSRRMetadataUpdate>>, {contractAddress: string;tokenFile: string;data: Object}> = (props) => {
          const {contractAddress,tokenFile,data} = props ?? {};

          return  sRRControllerCollectionSRRMetadataUpdate(contractAddress,tokenFile,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionSRRMetadataUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionSRRMetadataUpdate>>>
    export type SRRControllerCollectionSRRMetadataUpdateMutationBody = Object
    export type SRRControllerCollectionSRRMetadataUpdateMutationError = ErrorType<unknown>

    /**
 * @summary Update token metadata JSON from a collection contract
 */
export const useSRRControllerCollectionSRRMetadataUpdate = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionSRRMetadataUpdate>>, TError,{contractAddress: string;tokenFile: string;data: Object}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionSRRMetadataUpdateMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get Metadata History for a Collection SRR.
 * @summary Get the all metadata records that have been set on a Collection SRR
 */
export const sRRControllerCollectionGetMetadataHistory = (
    contractAddress: string,
    tokenId: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/${contractAddress}/${tokenId}/history`, method: 'get', signal
    },
      options);
    }
  

export const getSRRControllerCollectionGetMetadataHistoryQueryKey = (contractAddress: string,
    tokenId: string,) => [`/api/v1/srr/metadata/${contractAddress}/${tokenId}/history`] as const;
  

    
export const getSRRControllerCollectionGetMetadataHistoryQueryOptions = <TData = Awaited<ReturnType<typeof sRRControllerCollectionGetMetadataHistory>>, TError = ErrorType<unknown>>(contractAddress: string,
    tokenId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerCollectionGetMetadataHistory>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof sRRControllerCollectionGetMetadataHistory>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSRRControllerCollectionGetMetadataHistoryQueryKey(contractAddress,tokenId);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof sRRControllerCollectionGetMetadataHistory>>> = ({ signal }) => sRRControllerCollectionGetMetadataHistory(contractAddress,tokenId, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(contractAddress && tokenId), ...queryOptions}}

export type SRRControllerCollectionGetMetadataHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionGetMetadataHistory>>>
export type SRRControllerCollectionGetMetadataHistoryQueryError = ErrorType<unknown>

/**
 * @summary Get the all metadata records that have been set on a Collection SRR
 */
export const useSRRControllerCollectionGetMetadataHistory = <TData = Awaited<ReturnType<typeof sRRControllerCollectionGetMetadataHistory>>, TError = ErrorType<unknown>>(
 contractAddress: string,
    tokenId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sRRControllerCollectionGetMetadataHistory>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSRRControllerCollectionGetMetadataHistoryQueryOptions(contractAddress,tokenId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Update details of an SRR from a collection contract
 */
export const sRRControllerCollectionUpdateSRR = (
    contractAddress: string,
    tokenId: string,
    updateCollectionSRRDto: UpdateCollectionSRRDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: updateCollectionSRRDto
    },
      options);
    }
  


export const getSRRControllerCollectionUpdateSRRMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionUpdateSRR>>, TError,{contractAddress: string;tokenId: string;data: UpdateCollectionSRRDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionUpdateSRR>>, TError,{contractAddress: string;tokenId: string;data: UpdateCollectionSRRDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionUpdateSRR>>, {contractAddress: string;tokenId: string;data: UpdateCollectionSRRDto}> = (props) => {
          const {contractAddress,tokenId,data} = props ?? {};

          return  sRRControllerCollectionUpdateSRR(contractAddress,tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionUpdateSRRMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionUpdateSRR>>>
    export type SRRControllerCollectionUpdateSRRMutationBody = UpdateCollectionSRRDto
    export type SRRControllerCollectionUpdateSRRMutationError = ErrorType<unknown>

    /**
 * @summary Update details of an SRR from a collection contract
 */
export const useSRRControllerCollectionUpdateSRR = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionUpdateSRR>>, TError,{contractAddress: string;tokenId: string;data: UpdateCollectionSRRDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionUpdateSRRMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Build typed data for an Update SRR request from a collection contract
 */
export const sRRControllerCollectionUpdateSRRTypedData = (
    contractAddress: string,
    tokenId: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getSRRControllerCollectionUpdateSRRTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionUpdateSRRTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionUpdateSRRTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionUpdateSRRTypedData>>, {contractAddress: string;tokenId: string;data: GetTypedDataLuDto}> = (props) => {
          const {contractAddress,tokenId,data} = props ?? {};

          return  sRRControllerCollectionUpdateSRRTypedData(contractAddress,tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionUpdateSRRTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionUpdateSRRTypedData>>>
    export type SRRControllerCollectionUpdateSRRTypedDataMutationBody = GetTypedDataLuDto
    export type SRRControllerCollectionUpdateSRRTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for an Update SRR request from a collection contract
 */
export const useSRRControllerCollectionUpdateSRRTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionUpdateSRRTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionUpdateSRRTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Build typed data for an Update Metadata request from a collection contract
 */
export const sRRControllerCollectionSRRMetadataUpdateTypedData = (
    contractAddress: string,
    tokenFile: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/${contractAddress}/${tokenFile}/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getSRRControllerCollectionSRRMetadataUpdateTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionSRRMetadataUpdateTypedData>>, TError,{contractAddress: string;tokenFile: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionSRRMetadataUpdateTypedData>>, TError,{contractAddress: string;tokenFile: string;data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionSRRMetadataUpdateTypedData>>, {contractAddress: string;tokenFile: string;data: GetTypedDataLuDto}> = (props) => {
          const {contractAddress,tokenFile,data} = props ?? {};

          return  sRRControllerCollectionSRRMetadataUpdateTypedData(contractAddress,tokenFile,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionSRRMetadataUpdateTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionSRRMetadataUpdateTypedData>>>
    export type SRRControllerCollectionSRRMetadataUpdateTypedDataMutationBody = GetTypedDataLuDto
    export type SRRControllerCollectionSRRMetadataUpdateTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for an Update Metadata request from a collection contract
 */
export const useSRRControllerCollectionSRRMetadataUpdateTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionSRRMetadataUpdateTypedData>>, TError,{contractAddress: string;tokenFile: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionSRRMetadataUpdateTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Collection: Approve transfer by secret string to be used in a commit/reveal scheme where a double hash of the secret is used on commit / approval and a single hash is used on reveal / transfer. 
 * @summary Collection: Approve an SRR transfer by secret commitment
 */
export const sRRControllerCollectionApproveByCommitment = (
    contractAddress: string,
    tokenId: string,
    approveSRRByCommitmentDto: ApproveSRRByCommitmentDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/approveByCommitment`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: approveSRRByCommitmentDto
    },
      options);
    }
  


export const getSRRControllerCollectionApproveByCommitmentMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionApproveByCommitment>>, TError,{contractAddress: string;tokenId: string;data: ApproveSRRByCommitmentDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionApproveByCommitment>>, TError,{contractAddress: string;tokenId: string;data: ApproveSRRByCommitmentDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionApproveByCommitment>>, {contractAddress: string;tokenId: string;data: ApproveSRRByCommitmentDto}> = (props) => {
          const {contractAddress,tokenId,data} = props ?? {};

          return  sRRControllerCollectionApproveByCommitment(contractAddress,tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionApproveByCommitmentMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionApproveByCommitment>>>
    export type SRRControllerCollectionApproveByCommitmentMutationBody = ApproveSRRByCommitmentDto
    export type SRRControllerCollectionApproveByCommitmentMutationError = ErrorType<void>

    /**
 * @summary Collection: Approve an SRR transfer by secret commitment
 */
export const useSRRControllerCollectionApproveByCommitment = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionApproveByCommitment>>, TError,{contractAddress: string;tokenId: string;data: ApproveSRRByCommitmentDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionApproveByCommitmentMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Collection: Cancels an approval set by /approveByCommitment
 * @summary Collection: Cancel a prior approveByCommitment
 */
export const sRRControllerCollectionCancelApproved = (
    contractAddress: string,
    tokenId: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/approveByCommitment`, method: 'delete'
    },
      options);
    }
  


export const getSRRControllerCollectionCancelApprovedMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionCancelApproved>>, TError,{contractAddress: string;tokenId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionCancelApproved>>, TError,{contractAddress: string;tokenId: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionCancelApproved>>, {contractAddress: string;tokenId: string}> = (props) => {
          const {contractAddress,tokenId} = props ?? {};

          return  sRRControllerCollectionCancelApproved(contractAddress,tokenId,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionCancelApprovedMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionCancelApproved>>>
    
    export type SRRControllerCollectionCancelApprovedMutationError = ErrorType<void>

    /**
 * @summary Collection: Cancel a prior approveByCommitment
 */
export const useSRRControllerCollectionCancelApproved = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionCancelApproved>>, TError,{contractAddress: string;tokenId: string}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionCancelApprovedMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Collection: Build typed data for an approve by commitment request
 */
export const sRRControllerCollectionApproveByCommitmentTypedData = (
    contractAddress: string,
    tokenId: string,
    getTypedDataDto: GetTypedDataDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/approveByCommitment/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataDto
    },
      options);
    }
  


export const getSRRControllerCollectionApproveByCommitmentTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionApproveByCommitmentTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionApproveByCommitmentTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionApproveByCommitmentTypedData>>, {contractAddress: string;tokenId: string;data: GetTypedDataDto}> = (props) => {
          const {contractAddress,tokenId,data} = props ?? {};

          return  sRRControllerCollectionApproveByCommitmentTypedData(contractAddress,tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionApproveByCommitmentTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionApproveByCommitmentTypedData>>>
    export type SRRControllerCollectionApproveByCommitmentTypedDataMutationBody = GetTypedDataDto
    export type SRRControllerCollectionApproveByCommitmentTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Collection: Build typed data for an approve by commitment request
 */
export const useSRRControllerCollectionApproveByCommitmentTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionApproveByCommitmentTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionApproveByCommitmentTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Collection: Build typed data for a cancel approval request
 */
export const sRRControllerCollectionCancelApprovedTypedData = (
    contractAddress: string,
    tokenId: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/approveByCommitment/typedData`, method: 'delete',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getSRRControllerCollectionCancelApprovedTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionCancelApprovedTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionCancelApprovedTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionCancelApprovedTypedData>>, {contractAddress: string;tokenId: string;data: GetTypedDataLuDto}> = (props) => {
          const {contractAddress,tokenId,data} = props ?? {};

          return  sRRControllerCollectionCancelApprovedTypedData(contractAddress,tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionCancelApprovedTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionCancelApprovedTypedData>>>
    export type SRRControllerCollectionCancelApprovedTypedDataMutationBody = GetTypedDataLuDto
    export type SRRControllerCollectionCancelApprovedTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Collection: Build typed data for a cancel approval request
 */
export const useSRRControllerCollectionCancelApprovedTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionCancelApprovedTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionCancelApprovedTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Collection: Transfer SRR to a new owner providing a reveal hash, the hash of matches the commitment given in the approval stage. 
 * @summary Collection: Transfer SRR by reveal.
 */
export const sRRControllerCollectionTransferByReveal = (
    contractAddress: string,
    tokenId: string,
    transferSRRByRevealDto: TransferSRRByRevealDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/transferByReveal`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: transferSRRByRevealDto
    },
      options);
    }
  


export const getSRRControllerCollectionTransferByRevealMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionTransferByReveal>>, TError,{contractAddress: string;tokenId: string;data: TransferSRRByRevealDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionTransferByReveal>>, TError,{contractAddress: string;tokenId: string;data: TransferSRRByRevealDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionTransferByReveal>>, {contractAddress: string;tokenId: string;data: TransferSRRByRevealDto}> = (props) => {
          const {contractAddress,tokenId,data} = props ?? {};

          return  sRRControllerCollectionTransferByReveal(contractAddress,tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionTransferByRevealMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionTransferByReveal>>>
    export type SRRControllerCollectionTransferByRevealMutationBody = TransferSRRByRevealDto
    export type SRRControllerCollectionTransferByRevealMutationError = ErrorType<unknown>

    /**
 * @summary Collection: Transfer SRR by reveal.
 */
export const useSRRControllerCollectionTransferByReveal = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionTransferByReveal>>, TError,{contractAddress: string;tokenId: string;data: TransferSRRByRevealDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionTransferByRevealMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Transfer SRR on a Collection to new owner calling the ` + `transferFromWithProvenance function directly as a meta-tx
 * @summary Transfer SRR to new owner
 */
export const sRRControllerCollectionTransferFromWithProvenance = (
    contractAddress: string,
    tokenId: string,
    transferFromWithProvenanceDto: TransferFromWithProvenanceDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/transferFromWithProvenance`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: transferFromWithProvenanceDto
    },
      options);
    }
  


export const getSRRControllerCollectionTransferFromWithProvenanceMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionTransferFromWithProvenance>>, TError,{contractAddress: string;tokenId: string;data: TransferFromWithProvenanceDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionTransferFromWithProvenance>>, TError,{contractAddress: string;tokenId: string;data: TransferFromWithProvenanceDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionTransferFromWithProvenance>>, {contractAddress: string;tokenId: string;data: TransferFromWithProvenanceDto}> = (props) => {
          const {contractAddress,tokenId,data} = props ?? {};

          return  sRRControllerCollectionTransferFromWithProvenance(contractAddress,tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionTransferFromWithProvenanceMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionTransferFromWithProvenance>>>
    export type SRRControllerCollectionTransferFromWithProvenanceMutationBody = TransferFromWithProvenanceDto
    export type SRRControllerCollectionTransferFromWithProvenanceMutationError = ErrorType<void>

    /**
 * @summary Transfer SRR to new owner
 */
export const useSRRControllerCollectionTransferFromWithProvenance = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionTransferFromWithProvenance>>, TError,{contractAddress: string;tokenId: string;data: TransferFromWithProvenanceDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionTransferFromWithProvenanceMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Build typed data for a transfer from with provenance on collection request
 */
export const sRRControllerCollectionTransferFromTypedData = (
    contractAddress: string,
    tokenId: string,
    getTypedDataDto: GetTypedDataDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/transferFromWithProvenance/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataDto
    },
      options);
    }
  


export const getSRRControllerCollectionTransferFromTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionTransferFromTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionTransferFromTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionTransferFromTypedData>>, {contractAddress: string;tokenId: string;data: GetTypedDataDto}> = (props) => {
          const {contractAddress,tokenId,data} = props ?? {};

          return  sRRControllerCollectionTransferFromTypedData(contractAddress,tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionTransferFromTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionTransferFromTypedData>>>
    export type SRRControllerCollectionTransferFromTypedDataMutationBody = GetTypedDataDto
    export type SRRControllerCollectionTransferFromTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for a transfer from with provenance on collection request
 */
export const useSRRControllerCollectionTransferFromTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionTransferFromTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionTransferFromTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Collection: Disable/Enable standard ERC721 transfer methods
 * @summary Collection: Disable/Enable standard ERC721 transfer methods
 */
export const sRRControllerCollectionSetLockExternalTransfer = (
    contractAddress: string,
    tokenId: string,
    setLockExternalTranferDto: SetLockExternalTranferDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/lockExternalTransfer`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: setLockExternalTranferDto
    },
      options);
    }
  


export const getSRRControllerCollectionSetLockExternalTransferMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionSetLockExternalTransfer>>, TError,{contractAddress: string;tokenId: string;data: SetLockExternalTranferDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionSetLockExternalTransfer>>, TError,{contractAddress: string;tokenId: string;data: SetLockExternalTranferDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionSetLockExternalTransfer>>, {contractAddress: string;tokenId: string;data: SetLockExternalTranferDto}> = (props) => {
          const {contractAddress,tokenId,data} = props ?? {};

          return  sRRControllerCollectionSetLockExternalTransfer(contractAddress,tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionSetLockExternalTransferMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionSetLockExternalTransfer>>>
    export type SRRControllerCollectionSetLockExternalTransferMutationBody = SetLockExternalTranferDto
    export type SRRControllerCollectionSetLockExternalTransferMutationError = ErrorType<void>

    /**
 * @summary Collection: Disable/Enable standard ERC721 transfer methods
 */
export const useSRRControllerCollectionSetLockExternalTransfer = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionSetLockExternalTransfer>>, TError,{contractAddress: string;tokenId: string;data: SetLockExternalTranferDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionSetLockExternalTransferMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Collection: Build typed data for disable/enable standard ERC721 transfer methods
 */
export const sRRControllerCollectionSetLockExternalTransferTypedData = (
    contractAddress: string,
    tokenId: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/lockExternalTransfer/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getSRRControllerCollectionSetLockExternalTransferTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionSetLockExternalTransferTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionSetLockExternalTransferTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionSetLockExternalTransferTypedData>>, {contractAddress: string;tokenId: string;data: GetTypedDataLuDto}> = (props) => {
          const {contractAddress,tokenId,data} = props ?? {};

          return  sRRControllerCollectionSetLockExternalTransferTypedData(contractAddress,tokenId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionSetLockExternalTransferTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionSetLockExternalTransferTypedData>>>
    export type SRRControllerCollectionSetLockExternalTransferTypedDataMutationBody = GetTypedDataLuDto
    export type SRRControllerCollectionSetLockExternalTransferTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Collection: Build typed data for disable/enable standard ERC721 transfer methods
 */
export const useSRRControllerCollectionSetLockExternalTransferTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionSetLockExternalTransferTypedData>>, TError,{contractAddress: string;tokenId: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionSetLockExternalTransferTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Build typed data for for associating Collection SRRs with existing custom histories
 * @summary Build typed data for for associating custom histories with Collection SRRs
 */
export const sRRControllerCollectionAddHistoryTypedData = (
    contractAddress: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void | TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/history/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getSRRControllerCollectionAddHistoryTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionAddHistoryTypedData>>, TError,{contractAddress: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionAddHistoryTypedData>>, TError,{contractAddress: string;data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionAddHistoryTypedData>>, {contractAddress: string;data: GetTypedDataLuDto}> = (props) => {
          const {contractAddress,data} = props ?? {};

          return  sRRControllerCollectionAddHistoryTypedData(contractAddress,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionAddHistoryTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionAddHistoryTypedData>>>
    export type SRRControllerCollectionAddHistoryTypedDataMutationBody = GetTypedDataLuDto
    export type SRRControllerCollectionAddHistoryTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for for associating custom histories with Collection SRRs
 */
export const useSRRControllerCollectionAddHistoryTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionAddHistoryTypedData>>, TError,{contractAddress: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionAddHistoryTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Associate Collection SRRs with existing custom histories
 * @summary Associate Collection SRRs with existing custom histories
 */
export const sRRControllerCollectionAddHistory = (
    contractAddress: string,
    addHistoryDto: AddHistoryDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/history`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: addHistoryDto
    },
      options);
    }
  


export const getSRRControllerCollectionAddHistoryMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionAddHistory>>, TError,{contractAddress: string;data: AddHistoryDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionAddHistory>>, TError,{contractAddress: string;data: AddHistoryDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sRRControllerCollectionAddHistory>>, {contractAddress: string;data: AddHistoryDto}> = (props) => {
          const {contractAddress,data} = props ?? {};

          return  sRRControllerCollectionAddHistory(contractAddress,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type SRRControllerCollectionAddHistoryMutationResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionAddHistory>>>
    export type SRRControllerCollectionAddHistoryMutationBody = AddHistoryDto
    export type SRRControllerCollectionAddHistoryMutationError = ErrorType<void>

    /**
 * @summary Associate Collection SRRs with existing custom histories
 */
export const useSRRControllerCollectionAddHistory = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sRRControllerCollectionAddHistory>>, TError,{contractAddress: string;data: AddHistoryDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getSRRControllerCollectionAddHistoryMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Creates a new LicensedUserWallet contract on Startrail.<br/><br/>NOTE: You MUST provide the Admin token to be authorized.<br/><br/>CLICK THE LOCK ICON ON THE RIGHT TO SET THE AUTH TOKEN
 * @summary Create a LicensedUserWallet contract
 */
export const licensedUserControllerCreateLicensedUserWallet = (
    createLicensedUserWalletDto: CreateLicensedUserWalletDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/licensedUser`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createLicensedUserWalletDto
    },
      options);
    }
  


export const getLicensedUserControllerCreateLicensedUserWalletMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerCreateLicensedUserWallet>>, TError,{data: CreateLicensedUserWalletDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerCreateLicensedUserWallet>>, TError,{data: CreateLicensedUserWalletDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof licensedUserControllerCreateLicensedUserWallet>>, {data: CreateLicensedUserWalletDto}> = (props) => {
          const {data} = props ?? {};

          return  licensedUserControllerCreateLicensedUserWallet(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type LicensedUserControllerCreateLicensedUserWalletMutationResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerCreateLicensedUserWallet>>>
    export type LicensedUserControllerCreateLicensedUserWalletMutationBody = CreateLicensedUserWalletDto
    export type LicensedUserControllerCreateLicensedUserWalletMutationError = ErrorType<unknown>

    /**
 * @summary Create a LicensedUserWallet contract
 */
export const useLicensedUserControllerCreateLicensedUserWallet = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerCreateLicensedUserWallet>>, TError,{data: CreateLicensedUserWalletDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getLicensedUserControllerCreateLicensedUserWalletMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get LicensedUserWallets by wallet address or by an ownerEOA
 * @summary Get LicensedUserWallets
 */
export const licensedUserControllerGetLicensedUserWallets = (
    params?: LicensedUserControllerGetLicensedUserWalletsParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<LicensedUserWallet[]>(
      {url: `/api/v1/licensedUser`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getLicensedUserControllerGetLicensedUserWalletsQueryKey = (params?: LicensedUserControllerGetLicensedUserWalletsParams,) => [`/api/v1/licensedUser`, ...(params ? [params]: [])] as const;
  

    
export const getLicensedUserControllerGetLicensedUserWalletsQueryOptions = <TData = Awaited<ReturnType<typeof licensedUserControllerGetLicensedUserWallets>>, TError = ErrorType<void>>(params?: LicensedUserControllerGetLicensedUserWalletsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof licensedUserControllerGetLicensedUserWallets>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof licensedUserControllerGetLicensedUserWallets>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLicensedUserControllerGetLicensedUserWalletsQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof licensedUserControllerGetLicensedUserWallets>>> = ({ signal }) => licensedUserControllerGetLicensedUserWallets(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type LicensedUserControllerGetLicensedUserWalletsQueryResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerGetLicensedUserWallets>>>
export type LicensedUserControllerGetLicensedUserWalletsQueryError = ErrorType<void>

/**
 * @summary Get LicensedUserWallets
 */
export const useLicensedUserControllerGetLicensedUserWallets = <TData = Awaited<ReturnType<typeof licensedUserControllerGetLicensedUserWallets>>, TError = ErrorType<void>>(
 params?: LicensedUserControllerGetLicensedUserWalletsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof licensedUserControllerGetLicensedUserWallets>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getLicensedUserControllerGetLicensedUserWalletsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Allows admin to update a LU english name.<br/><br/>NOTE: You MUST provide the Admin token to be authorized.<br/><br/>CLICK THE LOCK ICON ON THE RIGHT TO SET THE AUTH TOKEN
 * @summary Update english name from a LicensedUserWallet contract
 */
export const licensedUserControllerSetEnglishName = (
    licensedUserWalletSetEnglishNameDto: LicensedUserWalletSetEnglishNameDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/licensedUser/setEnglishName`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: licensedUserWalletSetEnglishNameDto
    },
      options);
    }
  


export const getLicensedUserControllerSetEnglishNameMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerSetEnglishName>>, TError,{data: LicensedUserWalletSetEnglishNameDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerSetEnglishName>>, TError,{data: LicensedUserWalletSetEnglishNameDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof licensedUserControllerSetEnglishName>>, {data: LicensedUserWalletSetEnglishNameDto}> = (props) => {
          const {data} = props ?? {};

          return  licensedUserControllerSetEnglishName(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type LicensedUserControllerSetEnglishNameMutationResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerSetEnglishName>>>
    export type LicensedUserControllerSetEnglishNameMutationBody = LicensedUserWalletSetEnglishNameDto
    export type LicensedUserControllerSetEnglishNameMutationError = ErrorType<unknown>

    /**
 * @summary Update english name from a LicensedUserWallet contract
 */
export const useLicensedUserControllerSetEnglishName = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerSetEnglishName>>, TError,{data: LicensedUserWalletSetEnglishNameDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getLicensedUserControllerSetEnglishNameMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Allows admin to update a LU original name.<br/><br/>NOTE: You MUST provide the Admin token to be authorized.<br/><br/>CLICK THE LOCK ICON ON THE RIGHT TO SET THE AUTH TOKEN
 * @summary Update original name from a LicensedUserWallet contract
 */
export const licensedUserControllerSetOriginalName = (
    licensedUserWalletSetOriginalNameDto: LicensedUserWalletSetOriginalNameDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/licensedUser/setOriginalName`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: licensedUserWalletSetOriginalNameDto
    },
      options);
    }
  


export const getLicensedUserControllerSetOriginalNameMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerSetOriginalName>>, TError,{data: LicensedUserWalletSetOriginalNameDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerSetOriginalName>>, TError,{data: LicensedUserWalletSetOriginalNameDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof licensedUserControllerSetOriginalName>>, {data: LicensedUserWalletSetOriginalNameDto}> = (props) => {
          const {data} = props ?? {};

          return  licensedUserControllerSetOriginalName(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type LicensedUserControllerSetOriginalNameMutationResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerSetOriginalName>>>
    export type LicensedUserControllerSetOriginalNameMutationBody = LicensedUserWalletSetOriginalNameDto
    export type LicensedUserControllerSetOriginalNameMutationError = ErrorType<unknown>

    /**
 * @summary Update original name from a LicensedUserWallet contract
 */
export const useLicensedUserControllerSetOriginalName = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerSetOriginalName>>, TError,{data: LicensedUserWalletSetOriginalNameDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getLicensedUserControllerSetOriginalNameMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Allows admin to add new owners to the Wallet.<br/><br/>NOTE: You MUST provide the Admin token to be authorized.<br/><br/>CLICK THE LOCK ICON ON THE RIGHT TO SET THE AUTH TOKEN
 * @summary Add owners to a LicensedUserWallet contract
 */
export const licensedUserControllerAddOwners = (
    licensedUserWalletAddOwnerDto: LicensedUserWalletAddOwnerDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto[]>(
      {url: `/api/v1/licensedUser/owner`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: licensedUserWalletAddOwnerDto
    },
      options);
    }
  


export const getLicensedUserControllerAddOwnersMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerAddOwners>>, TError,{data: LicensedUserWalletAddOwnerDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerAddOwners>>, TError,{data: LicensedUserWalletAddOwnerDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof licensedUserControllerAddOwners>>, {data: LicensedUserWalletAddOwnerDto}> = (props) => {
          const {data} = props ?? {};

          return  licensedUserControllerAddOwners(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type LicensedUserControllerAddOwnersMutationResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerAddOwners>>>
    export type LicensedUserControllerAddOwnersMutationBody = LicensedUserWalletAddOwnerDto
    export type LicensedUserControllerAddOwnersMutationError = ErrorType<void>

    /**
 * @summary Add owners to a LicensedUserWallet contract
 */
export const useLicensedUserControllerAddOwners = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerAddOwners>>, TError,{data: LicensedUserWalletAddOwnerDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getLicensedUserControllerAddOwnersMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Allows admin to remove owners from the Wallet.<br/><br/>NOTE: You MUST provide the Admin token to be authorized.<br/><br/>CLICK THE LOCK ICON ON THE RIGHT TO SET THE AUTH TOKEN
 * @summary Remove owners from a LicensedUserWallet contract
 */
export const licensedUserControllerRemoveOwners = (
    licensedUserWalletRemoveOwnerDto: LicensedUserWalletRemoveOwnerDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto[]>(
      {url: `/api/v1/licensedUser/owner`, method: 'delete',
      headers: {'Content-Type': 'application/json', },
      data: licensedUserWalletRemoveOwnerDto
    },
      options);
    }
  


export const getLicensedUserControllerRemoveOwnersMutationOptions = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerRemoveOwners>>, TError,{data: LicensedUserWalletRemoveOwnerDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerRemoveOwners>>, TError,{data: LicensedUserWalletRemoveOwnerDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof licensedUserControllerRemoveOwners>>, {data: LicensedUserWalletRemoveOwnerDto}> = (props) => {
          const {data} = props ?? {};

          return  licensedUserControllerRemoveOwners(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type LicensedUserControllerRemoveOwnersMutationResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerRemoveOwners>>>
    export type LicensedUserControllerRemoveOwnersMutationBody = LicensedUserWalletRemoveOwnerDto
    export type LicensedUserControllerRemoveOwnersMutationError = ErrorType<void>

    /**
 * @summary Remove owners from a LicensedUserWallet contract
 */
export const useLicensedUserControllerRemoveOwners = <TError = ErrorType<void>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof licensedUserControllerRemoveOwners>>, TError,{data: LicensedUserWalletRemoveOwnerDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getLicensedUserControllerRemoveOwnersMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get a list of Collection Contracts owned by the input Licensed User Wallet contract address.
 * @summary Get a list of Collection Contracts owned by the input LUW contract address
 */
export const licensedUserControllerGetCollectionsByLUWContractAddress = (
    luwContractAddress: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<GetCollectionResponseDto[]>(
      {url: `/api/v1/licensedUser/${luwContractAddress}/collections`, method: 'get', signal
    },
      options);
    }
  

export const getLicensedUserControllerGetCollectionsByLUWContractAddressQueryKey = (luwContractAddress: string,) => [`/api/v1/licensedUser/${luwContractAddress}/collections`] as const;
  

    
export const getLicensedUserControllerGetCollectionsByLUWContractAddressQueryOptions = <TData = Awaited<ReturnType<typeof licensedUserControllerGetCollectionsByLUWContractAddress>>, TError = ErrorType<void>>(luwContractAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof licensedUserControllerGetCollectionsByLUWContractAddress>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof licensedUserControllerGetCollectionsByLUWContractAddress>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLicensedUserControllerGetCollectionsByLUWContractAddressQueryKey(luwContractAddress);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof licensedUserControllerGetCollectionsByLUWContractAddress>>> = ({ signal }) => licensedUserControllerGetCollectionsByLUWContractAddress(luwContractAddress, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(luwContractAddress), ...queryOptions}}

export type LicensedUserControllerGetCollectionsByLUWContractAddressQueryResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerGetCollectionsByLUWContractAddress>>>
export type LicensedUserControllerGetCollectionsByLUWContractAddressQueryError = ErrorType<void>

/**
 * @summary Get a list of Collection Contracts owned by the input LUW contract address
 */
export const useLicensedUserControllerGetCollectionsByLUWContractAddress = <TData = Awaited<ReturnType<typeof licensedUserControllerGetCollectionsByLUWContractAddress>>, TError = ErrorType<void>>(
 luwContractAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof licensedUserControllerGetCollectionsByLUWContractAddress>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getLicensedUserControllerGetCollectionsByLUWContractAddressQueryOptions(luwContractAddress,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const healthControllerHealthCheck = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<HealthControllerHealthCheck200>(
      {url: `/healthz`, method: 'get', signal
    },
      options);
    }
  

export const getHealthControllerHealthCheckQueryKey = () => [`/healthz`] as const;
  

    
export const getHealthControllerHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof healthControllerHealthCheck>>, TError = ErrorType<HealthControllerHealthCheck503>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof healthControllerHealthCheck>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof healthControllerHealthCheck>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthControllerHealthCheckQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthControllerHealthCheck>>> = ({ signal }) => healthControllerHealthCheck(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type HealthControllerHealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof healthControllerHealthCheck>>>
export type HealthControllerHealthCheckQueryError = ErrorType<HealthControllerHealthCheck503>

export const useHealthControllerHealthCheck = <TData = Awaited<ReturnType<typeof healthControllerHealthCheck>>, TError = ErrorType<HealthControllerHealthCheck503>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof healthControllerHealthCheck>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getHealthControllerHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const appInfoControllerGetVersion = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<void>(
      {url: `/info`, method: 'get', signal
    },
      options);
    }
  

export const getAppInfoControllerGetVersionQueryKey = () => [`/info`] as const;
  

    
export const getAppInfoControllerGetVersionQueryOptions = <TData = Awaited<ReturnType<typeof appInfoControllerGetVersion>>, TError = ErrorType<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof appInfoControllerGetVersion>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof appInfoControllerGetVersion>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppInfoControllerGetVersionQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof appInfoControllerGetVersion>>> = ({ signal }) => appInfoControllerGetVersion(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type AppInfoControllerGetVersionQueryResult = NonNullable<Awaited<ReturnType<typeof appInfoControllerGetVersion>>>
export type AppInfoControllerGetVersionQueryError = ErrorType<unknown>

export const useAppInfoControllerGetVersion = <TData = Awaited<ReturnType<typeof appInfoControllerGetVersion>>, TError = ErrorType<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof appInfoControllerGetVersion>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getAppInfoControllerGetVersionQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Administrator can get the current ITX gas tank
 */
export const appInfoControllerGetGasInfo = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<GasInfo>(
      {url: `/info/gas`, method: 'get', signal
    },
      options);
    }
  

export const getAppInfoControllerGetGasInfoQueryKey = () => [`/info/gas`] as const;
  

    
export const getAppInfoControllerGetGasInfoQueryOptions = <TData = Awaited<ReturnType<typeof appInfoControllerGetGasInfo>>, TError = ErrorType<void>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof appInfoControllerGetGasInfo>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof appInfoControllerGetGasInfo>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppInfoControllerGetGasInfoQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof appInfoControllerGetGasInfo>>> = ({ signal }) => appInfoControllerGetGasInfo(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type AppInfoControllerGetGasInfoQueryResult = NonNullable<Awaited<ReturnType<typeof appInfoControllerGetGasInfo>>>
export type AppInfoControllerGetGasInfoQueryError = ErrorType<void>

export const useAppInfoControllerGetGasInfo = <TData = Awaited<ReturnType<typeof appInfoControllerGetGasInfo>>, TError = ErrorType<void>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof appInfoControllerGetGasInfo>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getAppInfoControllerGetGasInfoQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Get details of transaction including it's status
 */
export const txControllerGetTx = (
    params?: TxControllerGetTxParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<TxReceiptResponseDto[]>(
      {url: `/api/v1/tx`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getTxControllerGetTxQueryKey = (params?: TxControllerGetTxParams,) => [`/api/v1/tx`, ...(params ? [params]: [])] as const;
  

    
export const getTxControllerGetTxQueryOptions = <TData = Awaited<ReturnType<typeof txControllerGetTx>>, TError = ErrorType<void>>(params?: TxControllerGetTxParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof txControllerGetTx>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof txControllerGetTx>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTxControllerGetTxQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof txControllerGetTx>>> = ({ signal }) => txControllerGetTx(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type TxControllerGetTxQueryResult = NonNullable<Awaited<ReturnType<typeof txControllerGetTx>>>
export type TxControllerGetTxQueryError = ErrorType<void>

export const useTxControllerGetTx = <TData = Awaited<ReturnType<typeof txControllerGetTx>>, TError = ErrorType<void>>(
 params?: TxControllerGetTxParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof txControllerGetTx>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getTxControllerGetTxQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Administrator can update the TxConfig values. A subset of TxConfig can be provided or ALL TxConfig properties can be provided.
 */
export const txControllerSetConfig = (
    txConfigDto: TxConfigDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/tx/config`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: txConfigDto
    },
      options);
    }
  


export const getTxControllerSetConfigMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof txControllerSetConfig>>, TError,{data: TxConfigDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof txControllerSetConfig>>, TError,{data: TxConfigDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof txControllerSetConfig>>, {data: TxConfigDto}> = (props) => {
          const {data} = props ?? {};

          return  txControllerSetConfig(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type TxControllerSetConfigMutationResult = NonNullable<Awaited<ReturnType<typeof txControllerSetConfig>>>
    export type TxControllerSetConfigMutationBody = TxConfigDto
    export type TxControllerSetConfigMutationError = ErrorType<unknown>

    export const useTxControllerSetConfig = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof txControllerSetConfig>>, TError,{data: TxConfigDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getTxControllerSetConfigMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Administrator can get the current TxConfig values.
 */
export const txControllerGetConfig = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<TxConfig>(
      {url: `/api/v1/tx/config`, method: 'get', signal
    },
      options);
    }
  

export const getTxControllerGetConfigQueryKey = () => [`/api/v1/tx/config`] as const;
  

    
export const getTxControllerGetConfigQueryOptions = <TData = Awaited<ReturnType<typeof txControllerGetConfig>>, TError = ErrorType<void>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof txControllerGetConfig>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof txControllerGetConfig>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTxControllerGetConfigQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof txControllerGetConfig>>> = ({ signal }) => txControllerGetConfig(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type TxControllerGetConfigQueryResult = NonNullable<Awaited<ReturnType<typeof txControllerGetConfig>>>
export type TxControllerGetConfigQueryError = ErrorType<void>

export const useTxControllerGetConfig = <TData = Awaited<ReturnType<typeof txControllerGetConfig>>, TError = ErrorType<void>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof txControllerGetConfig>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getTxControllerGetConfigQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Administrator update the overrideGasPriceGwei for a TxReceipt. If the tx is resubmitted due to timeout, this gas price will be used.
 */
export const txControllerSetOverrideGasPrice = (
    txReceiptId: number,
    txOverridePriceDto: TxOverridePriceDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/tx/${txReceiptId}/overrideGasPrice`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: txOverridePriceDto
    },
      options);
    }
  


export const getTxControllerSetOverrideGasPriceMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof txControllerSetOverrideGasPrice>>, TError,{txReceiptId: number;data: TxOverridePriceDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof txControllerSetOverrideGasPrice>>, TError,{txReceiptId: number;data: TxOverridePriceDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof txControllerSetOverrideGasPrice>>, {txReceiptId: number;data: TxOverridePriceDto}> = (props) => {
          const {txReceiptId,data} = props ?? {};

          return  txControllerSetOverrideGasPrice(txReceiptId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type TxControllerSetOverrideGasPriceMutationResult = NonNullable<Awaited<ReturnType<typeof txControllerSetOverrideGasPrice>>>
    export type TxControllerSetOverrideGasPriceMutationBody = TxOverridePriceDto
    export type TxControllerSetOverrideGasPriceMutationError = ErrorType<unknown>

    export const useTxControllerSetOverrideGasPrice = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof txControllerSetOverrideGasPrice>>, TError,{txReceiptId: number;data: TxOverridePriceDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getTxControllerSetOverrideGasPriceMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Administrator resend tx with broadcast failed status.
 */
export const txControllerResend = (
    txReceiptId: number,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/tx/${txReceiptId}/resend`, method: 'post'
    },
      options);
    }
  


export const getTxControllerResendMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof txControllerResend>>, TError,{txReceiptId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof txControllerResend>>, TError,{txReceiptId: number}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof txControllerResend>>, {txReceiptId: number}> = (props) => {
          const {txReceiptId} = props ?? {};

          return  txControllerResend(txReceiptId,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type TxControllerResendMutationResult = NonNullable<Awaited<ReturnType<typeof txControllerResend>>>
    
    export type TxControllerResendMutationError = ErrorType<unknown>

    export const useTxControllerResend = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof txControllerResend>>, TError,{txReceiptId: number}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getTxControllerResendMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get metadata JSON by a given digest.
 * @summary Get metadata JSON by digest or cid
 */
export const metadataControllerGetMetadataJSONByHash = (
    metadataHash: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<void>(
      {url: `/api/v1/metadata/${metadataHash}`, method: 'get', signal
    },
      options);
    }
  

export const getMetadataControllerGetMetadataJSONByHashQueryKey = (metadataHash: string,) => [`/api/v1/metadata/${metadataHash}`] as const;
  

    
export const getMetadataControllerGetMetadataJSONByHashQueryOptions = <TData = Awaited<ReturnType<typeof metadataControllerGetMetadataJSONByHash>>, TError = ErrorType<unknown>>(metadataHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof metadataControllerGetMetadataJSONByHash>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof metadataControllerGetMetadataJSONByHash>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMetadataControllerGetMetadataJSONByHashQueryKey(metadataHash);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof metadataControllerGetMetadataJSONByHash>>> = ({ signal }) => metadataControllerGetMetadataJSONByHash(metadataHash, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(metadataHash), ...queryOptions}}

export type MetadataControllerGetMetadataJSONByHashQueryResult = NonNullable<Awaited<ReturnType<typeof metadataControllerGetMetadataJSONByHash>>>
export type MetadataControllerGetMetadataJSONByHashQueryError = ErrorType<unknown>

/**
 * @summary Get metadata JSON by digest or cid
 */
export const useMetadataControllerGetMetadataJSONByHash = <TData = Awaited<ReturnType<typeof metadataControllerGetMetadataJSONByHash>>, TError = ErrorType<unknown>>(
 metadataHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof metadataControllerGetMetadataJSONByHash>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getMetadataControllerGetMetadataJSONByHashQueryOptions(metadataHash,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Get the JSON schema.
 * @summary Get the JSON schema
 */
export const schemaControllerGetJSONSchema = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<void>(
      {url: `/api/v1/schema/*`, method: 'get', signal
    },
      options);
    }
  

export const getSchemaControllerGetJSONSchemaQueryKey = () => [`/api/v1/schema/*`] as const;
  

    
export const getSchemaControllerGetJSONSchemaQueryOptions = <TData = Awaited<ReturnType<typeof schemaControllerGetJSONSchema>>, TError = ErrorType<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof schemaControllerGetJSONSchema>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof schemaControllerGetJSONSchema>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSchemaControllerGetJSONSchemaQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof schemaControllerGetJSONSchema>>> = ({ signal }) => schemaControllerGetJSONSchema(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type SchemaControllerGetJSONSchemaQueryResult = NonNullable<Awaited<ReturnType<typeof schemaControllerGetJSONSchema>>>
export type SchemaControllerGetJSONSchemaQueryError = ErrorType<unknown>

/**
 * @summary Get the JSON schema
 */
export const useSchemaControllerGetJSONSchema = <TData = Awaited<ReturnType<typeof schemaControllerGetJSONSchema>>, TError = ErrorType<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof schemaControllerGetJSONSchema>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSchemaControllerGetJSONSchemaQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Generate signed urls to upload or download files.
 */
export const certAttachmentFileControllerGeneratetFileSignedUrlsV2 = (
    generateSignedUrlsV2Request: GenerateSignedUrlsV2Request,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/certAttachmentFile/signedUrlsV2`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: generateSignedUrlsV2Request
    },
      options);
    }
  


export const getCertAttachmentFileControllerGeneratetFileSignedUrlsV2MutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGeneratetFileSignedUrlsV2>>, TError,{data: GenerateSignedUrlsV2Request}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGeneratetFileSignedUrlsV2>>, TError,{data: GenerateSignedUrlsV2Request}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof certAttachmentFileControllerGeneratetFileSignedUrlsV2>>, {data: GenerateSignedUrlsV2Request}> = (props) => {
          const {data} = props ?? {};

          return  certAttachmentFileControllerGeneratetFileSignedUrlsV2(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CertAttachmentFileControllerGeneratetFileSignedUrlsV2MutationResult = NonNullable<Awaited<ReturnType<typeof certAttachmentFileControllerGeneratetFileSignedUrlsV2>>>
    export type CertAttachmentFileControllerGeneratetFileSignedUrlsV2MutationBody = GenerateSignedUrlsV2Request
    export type CertAttachmentFileControllerGeneratetFileSignedUrlsV2MutationError = ErrorType<unknown>

    export const useCertAttachmentFileControllerGeneratetFileSignedUrlsV2 = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGeneratetFileSignedUrlsV2>>, TError,{data: GenerateSignedUrlsV2Request}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getCertAttachmentFileControllerGeneratetFileSignedUrlsV2MutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve file metadata of given filepaths from storage bucket.
 */
export const certAttachmentFileControllerGetFileMetadataV2 = (
    getFileMetadataV2Request: GetFileMetadataV2Request,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/certAttachmentFile/fileMetadataV2`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getFileMetadataV2Request
    },
      options);
    }
  


export const getCertAttachmentFileControllerGetFileMetadataV2MutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGetFileMetadataV2>>, TError,{data: GetFileMetadataV2Request}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGetFileMetadataV2>>, TError,{data: GetFileMetadataV2Request}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof certAttachmentFileControllerGetFileMetadataV2>>, {data: GetFileMetadataV2Request}> = (props) => {
          const {data} = props ?? {};

          return  certAttachmentFileControllerGetFileMetadataV2(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CertAttachmentFileControllerGetFileMetadataV2MutationResult = NonNullable<Awaited<ReturnType<typeof certAttachmentFileControllerGetFileMetadataV2>>>
    export type CertAttachmentFileControllerGetFileMetadataV2MutationBody = GetFileMetadataV2Request
    export type CertAttachmentFileControllerGetFileMetadataV2MutationError = ErrorType<unknown>

    export const useCertAttachmentFileControllerGetFileMetadataV2 = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGetFileMetadataV2>>, TError,{data: GetFileMetadataV2Request}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getCertAttachmentFileControllerGetFileMetadataV2MutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * DEPRECATED. Generate signed urls to upload/download Cert Attachment Files.
 * @deprecated
 */
export const certAttachmentFileControllerGenerateCertAttachmentFileSignedUrls = (
    certId: string,
    generateCertAttachmentFileSignedUrlsRequest: GenerateCertAttachmentFileSignedUrlsRequest,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/certAttachmentFile/signedUrls/${certId}`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: generateCertAttachmentFileSignedUrlsRequest
    },
      options);
    }
  


export const getCertAttachmentFileControllerGenerateCertAttachmentFileSignedUrlsMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGenerateCertAttachmentFileSignedUrls>>, TError,{certId: string;data: GenerateCertAttachmentFileSignedUrlsRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGenerateCertAttachmentFileSignedUrls>>, TError,{certId: string;data: GenerateCertAttachmentFileSignedUrlsRequest}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof certAttachmentFileControllerGenerateCertAttachmentFileSignedUrls>>, {certId: string;data: GenerateCertAttachmentFileSignedUrlsRequest}> = (props) => {
          const {certId,data} = props ?? {};

          return  certAttachmentFileControllerGenerateCertAttachmentFileSignedUrls(certId,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CertAttachmentFileControllerGenerateCertAttachmentFileSignedUrlsMutationResult = NonNullable<Awaited<ReturnType<typeof certAttachmentFileControllerGenerateCertAttachmentFileSignedUrls>>>
    export type CertAttachmentFileControllerGenerateCertAttachmentFileSignedUrlsMutationBody = GenerateCertAttachmentFileSignedUrlsRequest
    export type CertAttachmentFileControllerGenerateCertAttachmentFileSignedUrlsMutationError = ErrorType<unknown>

    /**
 * @deprecated
 */
export const useCertAttachmentFileControllerGenerateCertAttachmentFileSignedUrls = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGenerateCertAttachmentFileSignedUrls>>, TError,{certId: string;data: GenerateCertAttachmentFileSignedUrlsRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getCertAttachmentFileControllerGenerateCertAttachmentFileSignedUrlsMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * DEPRECATED. Generate signed urls to download files.
 * @deprecated
 */
export const certAttachmentFileControllerGeneratetFileSignedUrlsByPath = (
    generateSignedUrlsByPathsRequest: GenerateSignedUrlsByPathsRequest,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/certAttachmentFile/signedUrls`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: generateSignedUrlsByPathsRequest
    },
      options);
    }
  


export const getCertAttachmentFileControllerGeneratetFileSignedUrlsByPathMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGeneratetFileSignedUrlsByPath>>, TError,{data: GenerateSignedUrlsByPathsRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGeneratetFileSignedUrlsByPath>>, TError,{data: GenerateSignedUrlsByPathsRequest}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof certAttachmentFileControllerGeneratetFileSignedUrlsByPath>>, {data: GenerateSignedUrlsByPathsRequest}> = (props) => {
          const {data} = props ?? {};

          return  certAttachmentFileControllerGeneratetFileSignedUrlsByPath(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CertAttachmentFileControllerGeneratetFileSignedUrlsByPathMutationResult = NonNullable<Awaited<ReturnType<typeof certAttachmentFileControllerGeneratetFileSignedUrlsByPath>>>
    export type CertAttachmentFileControllerGeneratetFileSignedUrlsByPathMutationBody = GenerateSignedUrlsByPathsRequest
    export type CertAttachmentFileControllerGeneratetFileSignedUrlsByPathMutationError = ErrorType<unknown>

    /**
 * @deprecated
 */
export const useCertAttachmentFileControllerGeneratetFileSignedUrlsByPath = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGeneratetFileSignedUrlsByPath>>, TError,{data: GenerateSignedUrlsByPathsRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getCertAttachmentFileControllerGeneratetFileSignedUrlsByPathMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * DEPRECATED. Retrieve file metadata of given filepaths from storage bucket.
 * @deprecated
 */
export const certAttachmentFileControllerGetFileMetadata = (
    getFileMetadataRequest: GetFileMetadataRequest,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/certAttachmentFile/fileMetadata`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getFileMetadataRequest
    },
      options);
    }
  


export const getCertAttachmentFileControllerGetFileMetadataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGetFileMetadata>>, TError,{data: GetFileMetadataRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGetFileMetadata>>, TError,{data: GetFileMetadataRequest}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof certAttachmentFileControllerGetFileMetadata>>, {data: GetFileMetadataRequest}> = (props) => {
          const {data} = props ?? {};

          return  certAttachmentFileControllerGetFileMetadata(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CertAttachmentFileControllerGetFileMetadataMutationResult = NonNullable<Awaited<ReturnType<typeof certAttachmentFileControllerGetFileMetadata>>>
    export type CertAttachmentFileControllerGetFileMetadataMutationBody = GetFileMetadataRequest
    export type CertAttachmentFileControllerGetFileMetadataMutationError = ErrorType<unknown>

    /**
 * @deprecated
 */
export const useCertAttachmentFileControllerGetFileMetadata = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof certAttachmentFileControllerGetFileMetadata>>, TError,{data: GetFileMetadataRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getCertAttachmentFileControllerGetFileMetadataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get a Collection By contract Address.
 * @summary Get a Contract Collection By ContractAddress
 */
export const collectionControllerGetCollection = (
    contractAddress: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<GetCollectionResponseDto>(
      {url: `/api/v1/collection/${contractAddress}`, method: 'get', signal
    },
      options);
    }
  

export const getCollectionControllerGetCollectionQueryKey = (contractAddress: string,) => [`/api/v1/collection/${contractAddress}`] as const;
  

    
export const getCollectionControllerGetCollectionQueryOptions = <TData = Awaited<ReturnType<typeof collectionControllerGetCollection>>, TError = ErrorType<void>>(contractAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof collectionControllerGetCollection>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof collectionControllerGetCollection>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCollectionControllerGetCollectionQueryKey(contractAddress);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionControllerGetCollection>>> = ({ signal }) => collectionControllerGetCollection(contractAddress, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(contractAddress), ...queryOptions}}

export type CollectionControllerGetCollectionQueryResult = NonNullable<Awaited<ReturnType<typeof collectionControllerGetCollection>>>
export type CollectionControllerGetCollectionQueryError = ErrorType<void>

/**
 * @summary Get a Contract Collection By ContractAddress
 */
export const useCollectionControllerGetCollection = <TData = Awaited<ReturnType<typeof collectionControllerGetCollection>>, TError = ErrorType<void>>(
 contractAddress: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof collectionControllerGetCollection>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getCollectionControllerGetCollectionQueryOptions(contractAddress,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * Create a new Collection contract
 * @summary Create a new Collection contract
 */
export const collectionControllerCreateCollection = (
    createCollectionDto: CreateCollectionDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/collection`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createCollectionDto
    },
      options);
    }
  


export const getCollectionControllerCreateCollectionMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionControllerCreateCollection>>, TError,{data: CreateCollectionDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof collectionControllerCreateCollection>>, TError,{data: CreateCollectionDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof collectionControllerCreateCollection>>, {data: CreateCollectionDto}> = (props) => {
          const {data} = props ?? {};

          return  collectionControllerCreateCollection(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CollectionControllerCreateCollectionMutationResult = NonNullable<Awaited<ReturnType<typeof collectionControllerCreateCollection>>>
    export type CollectionControllerCreateCollectionMutationBody = CreateCollectionDto
    export type CollectionControllerCreateCollectionMutationError = ErrorType<unknown>

    /**
 * @summary Create a new Collection contract
 */
export const useCollectionControllerCreateCollection = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionControllerCreateCollection>>, TError,{data: CreateCollectionDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getCollectionControllerCreateCollectionMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Build typed data for a Collection creation request
 */
export const collectionControllerCreateCollectionTypedData = (
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/collection/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getCollectionControllerCreateCollectionTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionControllerCreateCollectionTypedData>>, TError,{data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof collectionControllerCreateCollectionTypedData>>, TError,{data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof collectionControllerCreateCollectionTypedData>>, {data: GetTypedDataLuDto}> = (props) => {
          const {data} = props ?? {};

          return  collectionControllerCreateCollectionTypedData(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CollectionControllerCreateCollectionTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof collectionControllerCreateCollectionTypedData>>>
    export type CollectionControllerCreateCollectionTypedDataMutationBody = GetTypedDataLuDto
    export type CollectionControllerCreateCollectionTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for a Collection creation request
 */
export const useCollectionControllerCreateCollectionTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionControllerCreateCollectionTypedData>>, TError,{data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getCollectionControllerCreateCollectionTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Transfer Collection ownership to another address
 * @summary Transfer Collection ownership to another address
 */
export const collectionControllerTransferOwnership = (
    contractAddress: string,
    collectionTransferOwnershipDto: CollectionTransferOwnershipDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/collection/${contractAddress}/transferOwnership`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: collectionTransferOwnershipDto
    },
      options);
    }
  


export const getCollectionControllerTransferOwnershipMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionControllerTransferOwnership>>, TError,{contractAddress: string;data: CollectionTransferOwnershipDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof collectionControllerTransferOwnership>>, TError,{contractAddress: string;data: CollectionTransferOwnershipDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof collectionControllerTransferOwnership>>, {contractAddress: string;data: CollectionTransferOwnershipDto}> = (props) => {
          const {contractAddress,data} = props ?? {};

          return  collectionControllerTransferOwnership(contractAddress,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CollectionControllerTransferOwnershipMutationResult = NonNullable<Awaited<ReturnType<typeof collectionControllerTransferOwnership>>>
    export type CollectionControllerTransferOwnershipMutationBody = CollectionTransferOwnershipDto
    export type CollectionControllerTransferOwnershipMutationError = ErrorType<unknown>

    /**
 * @summary Transfer Collection ownership to another address
 */
export const useCollectionControllerTransferOwnership = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionControllerTransferOwnership>>, TError,{contractAddress: string;data: CollectionTransferOwnershipDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getCollectionControllerTransferOwnershipMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Build typed data for a Collection transferOwnership request
 */
export const collectionControllerTransferOwnershipTypedData = (
    contractAddress: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/collection/${contractAddress}/transferOwnership/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  


export const getCollectionControllerTransferOwnershipTypedDataMutationOptions = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionControllerTransferOwnershipTypedData>>, TError,{contractAddress: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof collectionControllerTransferOwnershipTypedData>>, TError,{contractAddress: string;data: GetTypedDataLuDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof collectionControllerTransferOwnershipTypedData>>, {contractAddress: string;data: GetTypedDataLuDto}> = (props) => {
          const {contractAddress,data} = props ?? {};

          return  collectionControllerTransferOwnershipTypedData(contractAddress,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CollectionControllerTransferOwnershipTypedDataMutationResult = NonNullable<Awaited<ReturnType<typeof collectionControllerTransferOwnershipTypedData>>>
    export type CollectionControllerTransferOwnershipTypedDataMutationBody = GetTypedDataLuDto
    export type CollectionControllerTransferOwnershipTypedDataMutationError = ErrorType<unknown>

    /**
 * @summary Build typed data for a Collection transferOwnership request
 */
export const useCollectionControllerTransferOwnershipTypedData = <TError = ErrorType<unknown>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionControllerTransferOwnershipTypedData>>, TError,{contractAddress: string;data: GetTypedDataLuDto}, TContext>, request?: SecondParameter<typeof axiosInstance>}
) => {
    
      const mutationOptions = getCollectionControllerTransferOwnershipTypedDataMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * Get an intentional exception by httpCode and errorMessage to test alerts
 * @summary Get an intentional exception
 */
export const exceptionTestControllerGetException = (
    params: ExceptionTestControllerGetExceptionParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      return axiosInstance<void>(
      {url: `/api/v1/exception-test`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getExceptionTestControllerGetExceptionQueryKey = (params: ExceptionTestControllerGetExceptionParams,) => [`/api/v1/exception-test`, ...(params ? [params]: [])] as const;
  

    
export const getExceptionTestControllerGetExceptionQueryOptions = <TData = Awaited<ReturnType<typeof exceptionTestControllerGetException>>, TError = ErrorType<unknown>>(params: ExceptionTestControllerGetExceptionParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof exceptionTestControllerGetException>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof exceptionTestControllerGetException>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExceptionTestControllerGetExceptionQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof exceptionTestControllerGetException>>> = ({ signal }) => exceptionTestControllerGetException(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ExceptionTestControllerGetExceptionQueryResult = NonNullable<Awaited<ReturnType<typeof exceptionTestControllerGetException>>>
export type ExceptionTestControllerGetExceptionQueryError = ErrorType<unknown>

/**
 * @summary Get an intentional exception
 */
export const useExceptionTestControllerGetException = <TData = Awaited<ReturnType<typeof exceptionTestControllerGetException>>, TError = ErrorType<unknown>>(
 params: ExceptionTestControllerGetExceptionParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof exceptionTestControllerGetException>>, TError, TData>, request?: SecondParameter<typeof axiosInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getExceptionTestControllerGetExceptionQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


