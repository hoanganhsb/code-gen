/**
 * Generated by orval v6.17.0 üç∫
 * Do not edit manually.
 * Startrail-API
 * Startrail-API Endpoint List
 * OpenAPI spec version: 0.0.1
 */
import { axiosInstance } from '../util/axios-instance';
export type ExceptionTestControllerGetExceptionParams = {
/**
 * expected http code (https://github.com/nestjs/nest/blob/v8.3.1/packages/common/enums/http-status.enum.ts)
 */
httpCode: number;
/**
 * expected error message
 */
errorMessage: string;
};

export type TxControllerGetTxTxStatus = typeof TxControllerGetTxTxStatus[keyof typeof TxControllerGetTxTxStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TxControllerGetTxTxStatus = {
  pending: 'pending',
  success: 'success',
  failure: 'failure',
  mined: 'mined',
} as const;

export type TxControllerGetTxParams = {
/**
 * Query by transaction hash
 */
txHash?: string;
/**
 * The params are exclusive.
 */
txReceiptId?: number;
/**
 * Query by transaction status
 */
txStatus?: TxControllerGetTxTxStatus;
/**
 * Query by signer of meta-tx signature
 */
signingEOA?: string;
/**
 * Query by LicensedUserWallet the transaction was proxied through
 */
licensedUser?: string;
};

export type HealthControllerHealthCheck503Details = {[key: string]: {
  status?: string;
  [key: string]: string;
}};

export type HealthControllerHealthCheck503Error = {[key: string]: {
  status?: string;
  [key: string]: string;
}} | null;

export type HealthControllerHealthCheck503Info = {[key: string]: {
  status?: string;
  [key: string]: string;
}} | null;

export type HealthControllerHealthCheck503 = {
  status?: string;
  info?: HealthControllerHealthCheck503Info;
  error?: HealthControllerHealthCheck503Error;
  details?: HealthControllerHealthCheck503Details;
};

export type HealthControllerHealthCheck200Details = {[key: string]: {
  status?: string;
  [key: string]: string;
}};

export type HealthControllerHealthCheck200Error = {[key: string]: {
  status?: string;
  [key: string]: string;
}} | null;

export type HealthControllerHealthCheck200Info = {[key: string]: {
  status?: string;
  [key: string]: string;
}} | null;

export type HealthControllerHealthCheck200 = {
  status?: string;
  info?: HealthControllerHealthCheck200Info;
  error?: HealthControllerHealthCheck200Error;
  details?: HealthControllerHealthCheck200Details;
};

export type LicensedUserControllerGetLicensedUserWalletsParams = {
/**
 * Query by owner of LicensedUserWallet
 */
ownerEOA?: string;
/**
 * Query by LicensedUserWallet contract address
 */
walletAddress?: string;
/**
 * Limit the result set length to this number
 */
limit?: number;
/**
 * Order by Ascending (true) or Descending (false)
 */
orderAsc?: boolean;
};

export type SRRControllerGetSRRsParams = {
/**
 * Startrail Registry Record Token ID
 */
tokenId?: string;
/**
 * Query by collection contract address
 */
contractAddress?: string;
/**
 * Query by Owner EOA if Issuing LicensedUserWallet
 */
ownerEOA?: string;
/**
 * Query by Issuing LicensedUserWallet contract address
 */
issuerLUW?: string;
/**
 * The params are exclusive.
 */
txReceiptId?: number;
};

export interface CollectionTransferOwnershipDto {
  /** New address to transfer collection ownership too */
  newOwner: string;
}

export interface CreateCollectionDto {
  /** Collection name */
  name: string;
  /** Collection symbol */
  symbol: string;
  /** Create2 salt - salt used in Collection creation */
  salt?: string;
}

export interface GetFileMetadataRequest {
  /** An array of filepaths without bucket name */
  filepaths: string[];
  /** An optional array of booleans to determine the bucket for each filepath */
  isPrivateList: string[];
}

export interface GenerateSignedUrlsByPathsRequest {
  /** array of filepath without bucket name */
  filepaths: string[];
  /** An optional array of booleans to determine the bucket for each filepath */
  isPrivateList: string[];
}

export interface GenerateCertAttachmentFileSignedUrlsRequest {
  /** Array of name of the file to be saved under given cert ID in storage */
  filenames: string[];
  /** Enum for signedURL purpose, "read" to download, "write" to upload */
  action: string;
  /** An optional array of booleans to determine the bucket for each filepath */
  isPrivateList: string[];
}

/**
 * Enum for signedURL purpose, "read" to download, "write" to upload.
 */
export type GenerateSignedUrlsV2RequestAction = typeof GenerateSignedUrlsV2RequestAction[keyof typeof GenerateSignedUrlsV2RequestAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GenerateSignedUrlsV2RequestAction = {
  write: 'write',
  read: 'read',
} as const;

export interface FileInBucket {
  /** Filepath without bucket name. */
  filepath: string;
  /** Boolean to determine the bucket of the file. */
  isPrivate: boolean;
}

export interface GetFileMetadataV2Request {
  /** Array of file information. */
  files: FileInBucket[];
}

export interface GenerateSignedUrlsV2Request {
  /** Array of file information */
  files: FileInBucket[];
  /** Enum for signedURL purpose, "read" to download, "write" to upload. */
  action: GenerateSignedUrlsV2RequestAction;
}

export interface TxOverridePriceDto {
  /** Transactions that timeout will be resubmitted with this price if it's set. */
  overrideGasPriceGwei: number;
}

export interface TxConfig {
  /** Fixed id of 1 - only ever 1 row and it will always have id 1 */
  id: number;
  /** flag indicating the use of a fixed gas price */
  fixedGasPriceOn: boolean;
  /** gas price value for the default gas price in gwei */
  defaultGasPriceGwei: unknown;
  /** gas price value for the default maximum fee in gwei */
  defaultMaxFeePerGasPriceGwei: unknown;
  /** gas price value for the maximum priority fee in gwei */
  defaultMaxPriorityFeePerGasPriceGwei: unknown;
  /** time to wait for confirmation before transactions are resent with a higher bid */
  miningTimeoutSeconds: number;
  /** gas price value for the default gas price */
  oracleEndpoint: unknown;
  /** gas price level to set transaction processing speed */
  defaultGasLevel: unknown;
  /** flag indicating the usage of relaying admin signed transactions to a wrapping service */
  relayAdminTxByITX: boolean;
  /** flag indicating the usage of uploading metadata to ipfs */
  enableIpfs: boolean;
  /** flag indicating the usage of uploading file for contract terms and thumbnail to ipfs */
  enableIpfsForFile: boolean;
  /** flag enabling to use royalty - ERC2981 */
  enableRoyalty: boolean;
  /** flag indicating the usage of async transaction */
  asyncTxSend: boolean;
  /** gas price value for the default gas price */
  updatedAt: unknown;
}

/**
 * Default EthGasStation price level to use when dynamic prices is on and fixedGasPriceOn = false
 */
export type TxConfigDtoDefaultGasLevel = typeof TxConfigDtoDefaultGasLevel[keyof typeof TxConfigDtoDefaultGasLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TxConfigDtoDefaultGasLevel = {
  safelow: 'safelow',
  standard: 'standard',
  fast: 'fast',
  fastest: 'fastest',
} as const;

export interface TxConfigDto {
  /** Set to true to use fixed gas prices stored in the database.Set to false to use dynamic gas prices from EthGasStation. */
  fixedGasPriceOn: boolean;
  /** Gas price to submit transactions with when fixedGasPriceOn=true */
  defaultGasPriceGwei: number;
  /** Gas price to submit transactions max fee with when fixedGasPriceOn=true */
  defaultMaxFeePerGasPriceGwei: number;
  /** Gas price to submit transactions priority fee with when fixedGasPriceOn=true */
  defaultMaxPriorityFeePerGasPriceGwei: number;
  /** Resubmit pending transactions after they have been in the tx pool this many seconds */
  miningTimeoutSeconds: number;
  /** EthGasStation URL */
  oracleEndpoint: string;
  /** Default EthGasStation price level to use when dynamic prices is on and fixedGasPriceOn = false */
  defaultGasLevel: TxConfigDtoDefaultGasLevel;
  /** Feature flag enabling ITX relay to handle admin transactions */
  relayAdminTxByITX: boolean;
  /** Feature flag enabling to upload metadata to ipfs */
  enableIpfs: boolean;
  /** Feature flag enabling to upload file for contract terms and thumbnail to ipfs */
  enableIpfsForFile: boolean;
  /** Feature flag enabling to use royalty - ERC2981 */
  enableRoyalty: boolean;
  /** Feature flag enabling to send async transaction */
  asyncTxSend: boolean;
}

export type TxReceiptResponseDtoSigningEOA = { [key: string]: any };

export type TxReceiptResponseDtoHash = { [key: string]: any };

export interface TxReceiptResponseDto {
  txReceiptId: number;
  hash: TxReceiptResponseDtoHash;
  signingEOA: TxReceiptResponseDtoSigningEOA;
  txStatus: string;
  /** Transaction confirmed - a number of blocks have been mined since this one was mined */
  confirmed: boolean;
  errorReason: string;
  createdAt: string;
  updatedAt: string;
}

export interface GasInfo { [key: string]: any }

export interface GetCollectionResponseDto {
  /** Name of the collection. Will be the same as in metadata.name, but also stored on the contract */
  name: string;
  /** Symbol to identify the token  */
  symbol: string;
  /** Contract address of the collection contract. Will be visible on opensea. */
  contractAddress: string;
  /** Address of the owner of the collection. */
  ownerAddress: string;
  /** Collection Contract Metadata CID (TO BE REMOVED) */
  metadataCID: string;
  /** Collection created at */
  createdAt: string;
  /** Collection updated at */
  updatedAt: string;
}

export interface LicensedUserWallet { [key: string]: any }

export interface LicensedUserWalletRemoveOwnerDto {
  /** List of owners Ethereum addresses to remove */
  owners: string[];
  /** LUW Ethereum address */
  luwAddress: string;
}

export interface LicensedUserWalletAddOwnerDto {
  /** List of owners Ethereum addresses to add */
  owners: string[];
  /** LUW Ethereum address */
  luwAddress: string;
}

export interface LicensedUserWalletSetOriginalNameDto {
  /** LUW Ethereum address */
  luwAddress: string;
  /** Official name in original language */
  originalName: string;
}

export interface LicensedUserWalletSetEnglishNameDto {
  /** LUW Ethereum address */
  luwAddress: string;
  /** Official name in English */
  englishName: string;
}

/**
 * User type
 */
export type CreateLicensedUserWalletDtoUserType = typeof CreateLicensedUserWalletDtoUserType[keyof typeof CreateLicensedUserWalletDtoUserType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateLicensedUserWalletDtoUserType = {
  handler: 'handler',
  artist: 'artist',
} as const;

export interface CreateLicensedUserWalletDto {
  /** List of owners Ethereum addresses */
  owners: string[];
  /** Number of signatures required to approve a transaction */
  threshold: number;
  /** Official name in English */
  englishName: string;
  /** Official name in original language */
  originalName: string;
  /** User type */
  userType: CreateLicensedUserWalletDtoUserType;
  /** Create2 salt - a random salt is generated if none is given here */
  salt?: string;
}

export interface UpdateCollectionSRRDto {
  /** Issued by Primary Issuer flag */
  isPrimaryIssuer: boolean;
  /** Artist Ethereum Address */
  artistAddress: string;
}

/**
 * SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json
 */
export type CreateCollectionSRRDtoMetadata = { [key: string]: any };

export interface CreateCollectionSRRDto {
  /** Issued by Primary Issuer flag */
  isPrimaryIssuer: boolean;
  /** Artist Ethereum Address */
  artistAddress: string;
  /** SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json */
  metadata: CreateCollectionSRRDtoMetadata;
  /** SRR flag to disable standard ERC721 transfer methods */
  lockExternalTransfer: boolean;
  /** Recipient Ethereum Address */
  to: string;
}

export interface CheckERC2981RoyaltyResponse {
  /** SRR Royalty receiver, null if its ERC2981 is not activated or ineligible */
  royaltyReceiver: unknown;
  /** SRR royalty basis points, null if its ERC2981 is not activated or ineligible */
  royaltyBasisPoints: unknown;
}

/**
 * SRR Metadata (for draft SRR to check if metadata will apply ERC2981). This one is required if tokenId is not set
 */
export type CheckERC2981RoyaltyDtoMetadata = { [key: string]: any };

export interface CheckERC2981RoyaltyDto {
  /** Collection contract address. If this one is set, it will be utilized for the collection, otherwise, it will be applied for Startrail Registry. */
  contractAddress?: string;
  /** SRR Token ID (for already issued SRR). If this one is set, issuerAddress anb metadata will be ignored */
  tokenId?: string;
  /** SRR Metadata (for draft SRR to check if metadata will apply ERC2981). This one is required if tokenId is not set */
  metadata?: CheckERC2981RoyaltyDtoMetadata;
  /** Issuer Ethereum Address (for draft SRR). This one is required if tokenId is not set */
  issuerAddress?: string;
}

export interface SetLockExternalTranferDto {
  /** the flag to disable standard ERC721 transfer methods */
  flag: boolean;
}

export interface AddHistoryDto {
  /** Tokens to associate histories with */
  tokenIds: string[];
  /** History to associate tokens with */
  customHistoryIds: string[];
}

export interface CreateBatchTransferResponse {
  txReceiptId: number;
  batchId: number;
}

/**
 * Input values according to functionType
 */
export type GeneralizedBulkDtoData = { [key: string]: any };

export interface GeneralizedBulkDto {
  /** function type (createSRR, approveSRRByCommitment, transferFromWithProvenance) */
  functionType: string;
  /** Input values according to functionType */
  data: GeneralizedBulkDtoData;
}

export interface CreateGeneralizedBatchRequest {
  /** A JSON array of details of each transactions. */
  txs: GeneralizedBulkDto[];
}

/**
 * SRR Transfer Metadata conforming to the JSON schema registry-record-transfer-metadata.schema.json
 */
export type TransferFromWithProvenanceDtoMetadata = { [key: string]: any };

export interface TransferFromWithProvenanceDto {
  /** Address to transfer for ownership to. */
  to: string;
  /** SRR Transfer Metadata conforming to the JSON schema registry-record-transfer-metadata.schema.json */
  metadata: TransferFromWithProvenanceDtoMetadata;
  /** Intermediary flag used by startbahn to trigger a transaction. - defaults to false */
  isIntermediary: boolean;
}

export interface TransferSRRByRevealDto {
  /** Reveal hash the hash of which matches the commitment in the approveByCommitment */
  revealHash: string;
  /** Address to transfer for ownership to. */
  to: string;
  /** Intermediary flag used by startbahn to trigger a transaction. - defaults to false */
  isIntermediary: boolean;
}

/**
 * Nonce within the Channel (optional - will query blockchain for the next nonce)
 */
export type GetTypedDataDtoChannelNonce = { [key: string]: any };

/**
 * Nonce Channel to use (optional - defaults to 0)
 */
export type GetTypedDataDtoChannelId = { [key: string]: any };

/**
 * Request data for the meta transaction
 */
export type GetTypedDataDtoRequestData = { [key: string]: any };

export interface GetTypedDataDto {
  /** Request data for the meta transaction */
  requestData: GetTypedDataDtoRequestData;
  /** Nonce Channel to use (optional - defaults to 0) */
  channelId: GetTypedDataDtoChannelId;
  /** Nonce within the Channel (optional - will query blockchain for the next nonce) */
  channelNonce: GetTypedDataDtoChannelNonce;
  /** Address of licensed user wallet. If no datafield is set, it is regarded as tx from EOA */
  fromAddress: string;
}

/**
 * SRR Transfer Metadata conforming to the JSON schema registry-record-transfer-metadata.schema.json
 */
export type ApproveSRRByCommitmentDtoMetadata = { [key: string]: any };

export interface ApproveSRRByCommitmentDto {
  /** email to be used in the commit/reveal scheme. */
  preimage: string;
  /** single keccak256 hash of email to be used in the commit/reveal scheme. */
  revealHash: string;
  /** SRR Transfer Metadata conforming to the JSON schema registry-record-transfer-metadata.schema.json */
  metadata: ApproveSRRByCommitmentDtoMetadata;
}

/**
 * error message if it is emitted
 */
export type ConvertMetadataResponseMessage = { [key: string]: any };

/**
 * SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json
 */
export type ConvertMetadataResponseMetadata = { [key: string]: any };

export interface ConvertMetadataResponse {
  /** SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json */
  metadata: ConvertMetadataResponseMetadata;
  /** true if metadata is converted */
  isConverted: boolean;
  /** error message if it is emitted */
  message: ConvertMetadataResponseMessage;
}

/**
 * SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json
 */
export type ConvertMetadataDtoMetadata = { [key: string]: any };

export interface ConvertMetadataDto {
  /** SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json */
  metadata: ConvertMetadataDtoMetadata;
  /** artistName for metadata description */
  artistName: string;
  /** externalUrl */
  externalUrl: string;
  /** issuerName for metadata description */
  issuerName: string;
  /** tokenId by which SRR data is to be fetched to create metadata description */
  tokenId: string;
  /** collection address of the SRR */
  contractAddress: string;
}

export interface ConvertBatchMetadataRequestDto {
  /** SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json */
  metadataBatch: ConvertMetadataDto[];
}

export interface Object { [key: string]: any }

export interface UpdateSRRDto {
  /** Issued by Primary Issuer flag */
  isPrimaryIssuer: boolean;
  /** Artist Ethereum Address */
  artistAddress: string;
}

/**
 * Nonce within the Channel (optional - will query blockchain for the next nonce)
 */
export type GetTypedDataLuDtoChannelNonce = { [key: string]: any };

/**
 * Nonce Channel to use (optional - defaults to 0)
 */
export type GetTypedDataLuDtoChannelId = { [key: string]: any };

/**
 * Request data for the meta transaction
 */
export type GetTypedDataLuDtoRequestData = { [key: string]: any };

export interface GetTypedDataLuDto {
  /** Request data for the meta transaction */
  requestData: GetTypedDataLuDtoRequestData;
  /** Nonce Channel to use (optional - defaults to 0) */
  channelId: GetTypedDataLuDtoChannelId;
  /** Nonce within the Channel (optional - will query blockchain for the next nonce) */
  channelNonce: GetTypedDataLuDtoChannelNonce;
  /** Address of licensed user wallet */
  fromAddress: string;
}

/**
 * SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json
 */
export type CreateSRRDtoMetadata = { [key: string]: any };

export interface CreateSRRDto {
  /** Issued by Primary Issuer flag */
  isPrimaryIssuer: boolean;
  /** Artist Ethereum Address */
  artistAddress: string;
  /** SRR Metadata conforming to the JSON schema registry-record-metadata.schema.json */
  metadata: CreateSRRDtoMetadata;
  /** SRR flag to disable standard ERC721 transfer methods */
  lockExternalTransfer: boolean;
  /** Recipient Ethereum Address */
  to: string;
}

export interface Srr { [key: string]: any }

export interface AddCustomHistoryTypeDto {
  /** Name of Custom History Type in lower case */
  historyTypeName: string;
}

/**
 * Custom History Metadata conforming to one of the custom-history-* JSON schemas. See startrail-common-js metadata-schemas/.
 */
export type UpdateCustomHistoryDtoMetadata = { [key: string]: any };

export interface UpdateCustomHistoryDto {
  /** Custom History Metadata conforming to one of the custom-history-* JSON schemas. See startrail-common-js metadata-schemas/. */
  metadata: UpdateCustomHistoryDtoMetadata;
}

export interface TxResponseDto {
  txReceiptId: number;
}

/**
 * Additional Data that is not directly part of the custom history entry, optional. if used will link Certs to the history and notify other subsystems about the provided data
 */
export type CreateCustomHistoryDtoAdditionalOffChainMetadata = { [key: string]: any };

/**
 * Custom History Metadata conforming to one of the custom-history-* JSON schemas. See startrail-common-js metadata-schemas/.
 */
export type CreateCustomHistoryDtoMetadata = { [key: string]: any };

export interface CreateCustomHistoryDto {
  /** Custom History Metadata conforming to one of the custom-history-* JSON schemas. See startrail-common-js metadata-schemas/. */
  metadata: CreateCustomHistoryDtoMetadata;
  /** Additional Data that is not directly part of the custom history entry, optional. if used will link Certs to the history and notify other subsystems about the provided data */
  additionalOffChainMetadata: CreateCustomHistoryDtoAdditionalOffChainMetadata;
}




// eslint-disable-next-line
  type SecondParameter<T extends (...args: any) => any> = T extends (
  config: any,
  args: infer P,
) => any
  ? P
  : never;


  /**
 * Admin only route to create custom history as Metadata.
 * @summary Create custom history
 */
export const customHistoriesControllerCreateCustomHistory = (
    createCustomHistoryDto: CreateCustomHistoryDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/customHistories`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createCustomHistoryDto
    },
      options);
    }
  
/**
 * @summary Allow custom history metadata to be amended
 */
export const customHistoriesControllerUpdateCustomHistoryMetadata = (
    id: number,
    updateCustomHistoryDto: UpdateCustomHistoryDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/customHistories/${id}/metadata`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: updateCustomHistoryDto
    },
      options);
    }
  
/**
 * Get JSON schema for the Custom History of Auction Metadata JSON.
 * @summary Get the Custom History of Auction metadata JSON schema file
 */
export const customHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchema = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/customHistories/metadata/custom-history-of-auction-metadata.schema.json`, method: 'get'
    },
      options);
    }
  
/**
 * Admin only route to add custom history type.
 * @summary Add custom history type
 */
export const customHistoryControllerAddCustomHistoryType = (
    addCustomHistoryTypeDto: AddCustomHistoryTypeDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/customHistory/historyTypes`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: addCustomHistoryTypeDto
    },
      options);
    }
  
/**
 * Get a list of SRRs filtering by query parameters.
 * @summary Get a list of SRRs
 */
export const sRRControllerGetSRRs = (
    params?: SRRControllerGetSRRsParams,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<Srr[]>(
      {url: `/api/v1/srr`, method: 'get',
        params
    },
      options);
    }
  
/**
 * Issue a new SRR on Startrail. Sends a transaction to StartrailRegistry.createSRR.
 * @summary Issue a new SRR
 */
export const sRRControllerCreateSRR = (
    createSRRDto: CreateSRRDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createSRRDto
    },
      options);
    }
  
/**
 * @summary Build typed data for an Issue SRR request
 */
export const sRRControllerCreateSRRTypedData = (
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * Update details of an SRR on Startrail. Sends a transaction to StartrailRegistry.updateSRR.
 * @summary Update details of an SRR
 */
export const sRRControllerUpdateSRR = (
    tokenId: string,
    updateSRRDto: UpdateSRRDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${tokenId}`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: updateSRRDto
    },
      options);
    }
  
/**
 * @summary Build typed data for an Update SRR request
 */
export const sRRControllerUpdateSRRTypedData = (
    tokenId: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${tokenId}/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * Get metadata JSON for a given token.<br/>This is the ERC721 tokenURI().
 * @summary Get token metadata JSON
 */
export const sRRControllerGetMetadataJSONByTokenID = (
    tokenFile: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/${tokenFile}`, method: 'get'
    },
      options);
    }
  
/**
 * Update metadata JSON for a given token.<br/>This is the ERC721 tokenURI().
 * @summary Update token metadata JSON
 */
export const sRRControllerUpdateMetadata = (
    tokenFile: string,
    sRRControllerUpdateMetadataBody: Object,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/metadata/${tokenFile}`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: sRRControllerUpdateMetadataBody
    },
      options);
    }
  
/**
 * @summary Build typed data for an Update Metadata request
 */
export const sRRControllerUpdateMetadataTypedData = (
    tokenFile: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/${tokenFile}/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * Get the V1 JSON schema for the SRR Metadata JSON.
 * @summary Get the V1 SRR metadata JSON schema file
 */
export const sRRControllerGetMetadataJSONSchemaV1 = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/registry-record-metadata.schema.json`, method: 'get'
    },
      options);
    }
  
/**
 * Get the V1 JSON schema for the SRR Transfer Metadata JSON.
 * @summary Get the V1 SRR Transfer metadata JSON schema file
 */
export const sRRControllerGetTransferMetadataJSONSchemaV1 = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/registry-record-transfer-metadata.schema.json`, method: 'get'
    },
      options);
    }
  
/**
 * Get Metadata History for an SRR.
 * @summary Get the all metadata records that have been set on an SRR from issuance to now
 */
export const sRRControllerGetMetadataHistory = (
    tokenId: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/${tokenId}/history`, method: 'get'
    },
      options);
    }
  
/**
 * Metadata JSON is converted to the latest version according to the version schema
 * @summary Metadata JSON is converted to the latest version according to the version schema
 */
export const sRRControllerConvertMetadata = (
    convertBatchMetadataRequestDto: ConvertBatchMetadataRequestDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<ConvertMetadataResponse[]>(
      {url: `/api/v1/srr/metadata/convert`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: convertBatchMetadataRequestDto
    },
      options);
    }
  
/**
 * Approve transfer by secret string to be used in a commit/reveal scheme where a double hash of the secret is used on commit / approval and a single hash is used on reveal / transfer. 
 * @summary Approve an SRR transfer by secret commitment
 */
export const sRRControllerApproveByCommitment = (
    tokenId: string,
    approveSRRByCommitmentDto: ApproveSRRByCommitmentDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${tokenId}/approveByCommitment`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: approveSRRByCommitmentDto
    },
      options);
    }
  
/**
 * Cancels an approval set by /approveByCommitment
 * @summary Cancel a prior approveByCommitment
 */
export const sRRControllerCancelApproved = (
    tokenId: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${tokenId}/approveByCommitment`, method: 'delete'
    },
      options);
    }
  
/**
 * @summary Build typed data for an approve by commitment request
 */
export const sRRControllerApproveByCommitmentTypedData = (
    tokenId: string,
    getTypedDataDto: GetTypedDataDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${tokenId}/approveByCommitment/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataDto
    },
      options);
    }
  
/**
 * @summary Build typed data for a cancel approval request
 */
export const sRRControllerCancelApprovedTypedData = (
    tokenId: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${tokenId}/approveByCommitment/typedData`, method: 'delete',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * Transfer SRR to a new owner providing a reveal hash, the hash of matches the commitment given in the approval stage. 
 * @summary Transfer SRR by reveal.
 */
export const sRRControllerTransferByReveal = (
    tokenId: string,
    transferSRRByRevealDto: TransferSRRByRevealDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${tokenId}/transferByReveal`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: transferSRRByRevealDto
    },
      options);
    }
  
/**
 * Transfer SRR to new owner calling the transferFromWithProvenance function directly as a meta-tx
 * @summary Transfer SRR to new owner
 */
export const sRRControllerTransferFromWithProvenance = (
    tokenId: string,
    transferFromWithProvenanceDto: TransferFromWithProvenanceDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${tokenId}/transferFromWithProvenance`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: transferFromWithProvenanceDto
    },
      options);
    }
  
/**
 * @summary Build typed data for an safe transfer from request
 */
export const sRRControllerSafeTransferFromTypedData = (
    tokenId: string,
    getTypedDataDto: GetTypedDataDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${tokenId}/transferFromWithProvenance/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataDto
    },
      options);
    }
  
/**
 * A Generalized Batch endpoint
 * @summary A Generalized Batch endpoint
 */
export const sRRControllerCreateAndSendBatch = (
    createGeneralizedBatchRequest: CreateGeneralizedBatchRequest,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<CreateBatchTransferResponse>(
      {url: `/api/v1/srr/bulk`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createGeneralizedBatchRequest
    },
      options);
    }
  
/**
 * Build a typed data for a generalized bulk request.<br/>Return a MerkleRoot of a tree of generalized bulk leaf hashes. This root is to be signed by the sender.<br/>
 * @summary Build a typed data for a generalized bulk request
 */
export const sRRControllerCreateAndSendBatchTypedData = (
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/bulk/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * Get details of a generalized bulk given the batch id
 * @summary Get details of a generalized bulk
 */
export const sRRControllerGetBatch = (
    batchId: number,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/bulk/${batchId}`, method: 'get'
    },
      options);
    }
  
/**
 * Admin only route that can pause the generalized bulk queue.
 * @summary Pause processing of generalized bulk queue
 */
export const sRRControllerPauseGeneralizedBulkQueue = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/bulk/pause`, method: 'put'
    },
      options);
    }
  
/**
 * Admin only route that can resume the generalized bulk queue after a pause.
 * @summary Resume processing of generalized bulk queue
 */
export const sRRControllerResumeGeneralizedBulkQueue = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/bulk/resume`, method: 'put'
    },
      options);
    }
  
/**
 * Build typed data for for associating SRRs with existing custom histories
 * @summary Build typed data for for associating custom histories
 */
export const sRRControllerAddHistoryTypedData = (
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void | TxResponseDto>(
      {url: `/api/v1/srr/history/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * Associate SRRs with existing custom histories
 * @summary Associate SRRs with existing custom histories
 */
export const sRRControllerAddHistory = (
    addHistoryDto: AddHistoryDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/history`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: addHistoryDto
    },
      options);
    }
  
/**
 * Disable/Enable standard ERC721 transfer methods
 * @summary Disable/Enable standard ERC721 transfer methods
 */
export const sRRControllerSetLockExternalTransfer = (
    tokenId: string,
    setLockExternalTranferDto: SetLockExternalTranferDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${tokenId}/lockExternalTransfer`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: setLockExternalTranferDto
    },
      options);
    }
  
/**
 * @summary Build typed data for disable/enable standard ERC721 transfer methods
 */
export const sRRControllerSetLockExternalTransferTypedData = (
    tokenId: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${tokenId}/lockExternalTransfer/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * @summary Startrail Registry and Collection: ERC2981 eligibility checker
 */
export const sRRControllerCheckERC2981Royalty = (
    checkERC2981RoyaltyDto: CheckERC2981RoyaltyDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<CheckERC2981RoyaltyResponse>(
      {url: `/api/v1/srr/erc2981/checker`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: checkERC2981RoyaltyDto
    },
      options);
    }
  
/**
 * Create a new SRR to a collection
 * @summary Create a new SRR to a collection
 */
export const sRRControllerCreateCollectionSRR = (
    contractAddress: string,
    createCollectionSRRDto: CreateCollectionSRRDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createCollectionSRRDto
    },
      options);
    }
  
/**
 * @summary Build typed data for collection create srr
 */
export const sRRControllerCreateCollectionSRRTypeData = (
    contractAddress: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${contractAddress}/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * Get collection metadata JSON for a given token.<br/>This is the ERC721 tokenURI().
 * @summary Get token metadata JSON
 */
export const sRRControllerGetCollectionMetadataJSONByTokenID = (
    contractAddress: string,
    tokenFile: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/${contractAddress}/${tokenFile}`, method: 'get'
    },
      options);
    }
  
/**
 * Update metadata JSON for a given token from a collection contract.<br/>This is the ERC721 tokenURI().
 * @summary Update token metadata JSON from a collection contract
 */
export const sRRControllerCollectionSRRMetadataUpdate = (
    contractAddress: string,
    tokenFile: string,
    sRRControllerCollectionSRRMetadataUpdateBody: Object,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/metadata/${contractAddress}/${tokenFile}`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: sRRControllerCollectionSRRMetadataUpdateBody
    },
      options);
    }
  
/**
 * Get Metadata History for a Collection SRR.
 * @summary Get the all metadata records that have been set on a Collection SRR
 */
export const sRRControllerCollectionGetMetadataHistory = (
    contractAddress: string,
    tokenId: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/${contractAddress}/${tokenId}/history`, method: 'get'
    },
      options);
    }
  
/**
 * @summary Update details of an SRR from a collection contract
 */
export const sRRControllerCollectionUpdateSRR = (
    contractAddress: string,
    tokenId: string,
    updateCollectionSRRDto: UpdateCollectionSRRDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: updateCollectionSRRDto
    },
      options);
    }
  
/**
 * @summary Build typed data for an Update SRR request from a collection contract
 */
export const sRRControllerCollectionUpdateSRRTypedData = (
    contractAddress: string,
    tokenId: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * @summary Build typed data for an Update Metadata request from a collection contract
 */
export const sRRControllerCollectionSRRMetadataUpdateTypedData = (
    contractAddress: string,
    tokenFile: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/metadata/${contractAddress}/${tokenFile}/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * Collection: Approve transfer by secret string to be used in a commit/reveal scheme where a double hash of the secret is used on commit / approval and a single hash is used on reveal / transfer. 
 * @summary Collection: Approve an SRR transfer by secret commitment
 */
export const sRRControllerCollectionApproveByCommitment = (
    contractAddress: string,
    tokenId: string,
    approveSRRByCommitmentDto: ApproveSRRByCommitmentDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/approveByCommitment`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: approveSRRByCommitmentDto
    },
      options);
    }
  
/**
 * Collection: Cancels an approval set by /approveByCommitment
 * @summary Collection: Cancel a prior approveByCommitment
 */
export const sRRControllerCollectionCancelApproved = (
    contractAddress: string,
    tokenId: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/approveByCommitment`, method: 'delete'
    },
      options);
    }
  
/**
 * @summary Collection: Build typed data for an approve by commitment request
 */
export const sRRControllerCollectionApproveByCommitmentTypedData = (
    contractAddress: string,
    tokenId: string,
    getTypedDataDto: GetTypedDataDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/approveByCommitment/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataDto
    },
      options);
    }
  
/**
 * @summary Collection: Build typed data for a cancel approval request
 */
export const sRRControllerCollectionCancelApprovedTypedData = (
    contractAddress: string,
    tokenId: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/approveByCommitment/typedData`, method: 'delete',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * Collection: Transfer SRR to a new owner providing a reveal hash, the hash of matches the commitment given in the approval stage. 
 * @summary Collection: Transfer SRR by reveal.
 */
export const sRRControllerCollectionTransferByReveal = (
    contractAddress: string,
    tokenId: string,
    transferSRRByRevealDto: TransferSRRByRevealDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/transferByReveal`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: transferSRRByRevealDto
    },
      options);
    }
  
/**
 * Transfer SRR on a Collection to new owner calling the ` + `transferFromWithProvenance function directly as a meta-tx
 * @summary Transfer SRR to new owner
 */
export const sRRControllerCollectionTransferFromWithProvenance = (
    contractAddress: string,
    tokenId: string,
    transferFromWithProvenanceDto: TransferFromWithProvenanceDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/transferFromWithProvenance`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: transferFromWithProvenanceDto
    },
      options);
    }
  
/**
 * @summary Build typed data for a transfer from with provenance on collection request
 */
export const sRRControllerCollectionTransferFromTypedData = (
    contractAddress: string,
    tokenId: string,
    getTypedDataDto: GetTypedDataDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/transferFromWithProvenance/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataDto
    },
      options);
    }
  
/**
 * Collection: Disable/Enable standard ERC721 transfer methods
 * @summary Collection: Disable/Enable standard ERC721 transfer methods
 */
export const sRRControllerCollectionSetLockExternalTransfer = (
    contractAddress: string,
    tokenId: string,
    setLockExternalTranferDto: SetLockExternalTranferDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/lockExternalTransfer`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: setLockExternalTranferDto
    },
      options);
    }
  
/**
 * @summary Collection: Build typed data for disable/enable standard ERC721 transfer methods
 */
export const sRRControllerCollectionSetLockExternalTransferTypedData = (
    contractAddress: string,
    tokenId: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/srr/${contractAddress}/${tokenId}/lockExternalTransfer/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * Build typed data for for associating Collection SRRs with existing custom histories
 * @summary Build typed data for for associating custom histories with Collection SRRs
 */
export const sRRControllerCollectionAddHistoryTypedData = (
    contractAddress: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void | TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/history/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * Associate Collection SRRs with existing custom histories
 * @summary Associate Collection SRRs with existing custom histories
 */
export const sRRControllerCollectionAddHistory = (
    contractAddress: string,
    addHistoryDto: AddHistoryDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/srr/${contractAddress}/history`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: addHistoryDto
    },
      options);
    }
  
/**
 * Creates a new LicensedUserWallet contract on Startrail.<br/><br/>NOTE: You MUST provide the Admin token to be authorized.<br/><br/>CLICK THE LOCK ICON ON THE RIGHT TO SET THE AUTH TOKEN
 * @summary Create a LicensedUserWallet contract
 */
export const licensedUserControllerCreateLicensedUserWallet = (
    createLicensedUserWalletDto: CreateLicensedUserWalletDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/licensedUser`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createLicensedUserWalletDto
    },
      options);
    }
  
/**
 * Get LicensedUserWallets by wallet address or by an ownerEOA
 * @summary Get LicensedUserWallets
 */
export const licensedUserControllerGetLicensedUserWallets = (
    params?: LicensedUserControllerGetLicensedUserWalletsParams,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<LicensedUserWallet[]>(
      {url: `/api/v1/licensedUser`, method: 'get',
        params
    },
      options);
    }
  
/**
 * Allows admin to update a LU english name.<br/><br/>NOTE: You MUST provide the Admin token to be authorized.<br/><br/>CLICK THE LOCK ICON ON THE RIGHT TO SET THE AUTH TOKEN
 * @summary Update english name from a LicensedUserWallet contract
 */
export const licensedUserControllerSetEnglishName = (
    licensedUserWalletSetEnglishNameDto: LicensedUserWalletSetEnglishNameDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/licensedUser/setEnglishName`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: licensedUserWalletSetEnglishNameDto
    },
      options);
    }
  
/**
 * Allows admin to update a LU original name.<br/><br/>NOTE: You MUST provide the Admin token to be authorized.<br/><br/>CLICK THE LOCK ICON ON THE RIGHT TO SET THE AUTH TOKEN
 * @summary Update original name from a LicensedUserWallet contract
 */
export const licensedUserControllerSetOriginalName = (
    licensedUserWalletSetOriginalNameDto: LicensedUserWalletSetOriginalNameDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/licensedUser/setOriginalName`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: licensedUserWalletSetOriginalNameDto
    },
      options);
    }
  
/**
 * Allows admin to add new owners to the Wallet.<br/><br/>NOTE: You MUST provide the Admin token to be authorized.<br/><br/>CLICK THE LOCK ICON ON THE RIGHT TO SET THE AUTH TOKEN
 * @summary Add owners to a LicensedUserWallet contract
 */
export const licensedUserControllerAddOwners = (
    licensedUserWalletAddOwnerDto: LicensedUserWalletAddOwnerDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto[]>(
      {url: `/api/v1/licensedUser/owner`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: licensedUserWalletAddOwnerDto
    },
      options);
    }
  
/**
 * Allows admin to remove owners from the Wallet.<br/><br/>NOTE: You MUST provide the Admin token to be authorized.<br/><br/>CLICK THE LOCK ICON ON THE RIGHT TO SET THE AUTH TOKEN
 * @summary Remove owners from a LicensedUserWallet contract
 */
export const licensedUserControllerRemoveOwners = (
    licensedUserWalletRemoveOwnerDto: LicensedUserWalletRemoveOwnerDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto[]>(
      {url: `/api/v1/licensedUser/owner`, method: 'delete',
      headers: {'Content-Type': 'application/json', },
      data: licensedUserWalletRemoveOwnerDto
    },
      options);
    }
  
/**
 * Get a list of Collection Contracts owned by the input Licensed User Wallet contract address.
 * @summary Get a list of Collection Contracts owned by the input LUW contract address
 */
export const licensedUserControllerGetCollectionsByLUWContractAddress = (
    luwContractAddress: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<GetCollectionResponseDto[]>(
      {url: `/api/v1/licensedUser/${luwContractAddress}/collections`, method: 'get'
    },
      options);
    }
  
export const healthControllerHealthCheck = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<HealthControllerHealthCheck200>(
      {url: `/healthz`, method: 'get'
    },
      options);
    }
  
export const appInfoControllerGetVersion = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/info`, method: 'get'
    },
      options);
    }
  
/**
 * Administrator can get the current ITX gas tank
 */
export const appInfoControllerGetGasInfo = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<GasInfo>(
      {url: `/info/gas`, method: 'get'
    },
      options);
    }
  
/**
 * Get details of transaction including it's status
 */
export const txControllerGetTx = (
    params?: TxControllerGetTxParams,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxReceiptResponseDto[]>(
      {url: `/api/v1/tx`, method: 'get',
        params
    },
      options);
    }
  
/**
 * Administrator can update the TxConfig values. A subset of TxConfig can be provided or ALL TxConfig properties can be provided.
 */
export const txControllerSetConfig = (
    txConfigDto: TxConfigDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/tx/config`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: txConfigDto
    },
      options);
    }
  
/**
 * Administrator can get the current TxConfig values.
 */
export const txControllerGetConfig = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxConfig>(
      {url: `/api/v1/tx/config`, method: 'get'
    },
      options);
    }
  
/**
 * Administrator update the overrideGasPriceGwei for a TxReceipt. If the tx is resubmitted due to timeout, this gas price will be used.
 */
export const txControllerSetOverrideGasPrice = (
    txReceiptId: number,
    txOverridePriceDto: TxOverridePriceDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/tx/${txReceiptId}/overrideGasPrice`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: txOverridePriceDto
    },
      options);
    }
  
/**
 * Administrator resend tx with broadcast failed status.
 */
export const txControllerResend = (
    txReceiptId: number,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/tx/${txReceiptId}/resend`, method: 'post'
    },
      options);
    }
  
/**
 * Get metadata JSON by a given digest.
 * @summary Get metadata JSON by digest or cid
 */
export const metadataControllerGetMetadataJSONByHash = (
    metadataHash: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/metadata/${metadataHash}`, method: 'get'
    },
      options);
    }
  
/**
 * Get the JSON schema.
 * @summary Get the JSON schema
 */
export const schemaControllerGetJSONSchema = (
    
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/schema/*`, method: 'get'
    },
      options);
    }
  
/**
 * Generate signed urls to upload or download files.
 */
export const certAttachmentFileControllerGeneratetFileSignedUrlsV2 = (
    generateSignedUrlsV2Request: GenerateSignedUrlsV2Request,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/certAttachmentFile/signedUrlsV2`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: generateSignedUrlsV2Request
    },
      options);
    }
  
/**
 * Retrieve file metadata of given filepaths from storage bucket.
 */
export const certAttachmentFileControllerGetFileMetadataV2 = (
    getFileMetadataV2Request: GetFileMetadataV2Request,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/certAttachmentFile/fileMetadataV2`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getFileMetadataV2Request
    },
      options);
    }
  
/**
 * DEPRECATED. Generate signed urls to upload/download Cert Attachment Files.
 * @deprecated
 */
export const certAttachmentFileControllerGenerateCertAttachmentFileSignedUrls = (
    certId: string,
    generateCertAttachmentFileSignedUrlsRequest: GenerateCertAttachmentFileSignedUrlsRequest,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/certAttachmentFile/signedUrls/${certId}`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: generateCertAttachmentFileSignedUrlsRequest
    },
      options);
    }
  
/**
 * DEPRECATED. Generate signed urls to download files.
 * @deprecated
 */
export const certAttachmentFileControllerGeneratetFileSignedUrlsByPath = (
    generateSignedUrlsByPathsRequest: GenerateSignedUrlsByPathsRequest,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/certAttachmentFile/signedUrls`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: generateSignedUrlsByPathsRequest
    },
      options);
    }
  
/**
 * DEPRECATED. Retrieve file metadata of given filepaths from storage bucket.
 * @deprecated
 */
export const certAttachmentFileControllerGetFileMetadata = (
    getFileMetadataRequest: GetFileMetadataRequest,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/certAttachmentFile/fileMetadata`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getFileMetadataRequest
    },
      options);
    }
  
/**
 * Get a Collection By contract Address.
 * @summary Get a Contract Collection By ContractAddress
 */
export const collectionControllerGetCollection = (
    contractAddress: string,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<GetCollectionResponseDto>(
      {url: `/api/v1/collection/${contractAddress}`, method: 'get'
    },
      options);
    }
  
/**
 * Create a new Collection contract
 * @summary Create a new Collection contract
 */
export const collectionControllerCreateCollection = (
    createCollectionDto: CreateCollectionDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/collection`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createCollectionDto
    },
      options);
    }
  
/**
 * @summary Build typed data for a Collection creation request
 */
export const collectionControllerCreateCollectionTypedData = (
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/collection/typedData`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * Transfer Collection ownership to another address
 * @summary Transfer Collection ownership to another address
 */
export const collectionControllerTransferOwnership = (
    contractAddress: string,
    collectionTransferOwnershipDto: CollectionTransferOwnershipDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<TxResponseDto>(
      {url: `/api/v1/collection/${contractAddress}/transferOwnership`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: collectionTransferOwnershipDto
    },
      options);
    }
  
/**
 * @summary Build typed data for a Collection transferOwnership request
 */
export const collectionControllerTransferOwnershipTypedData = (
    contractAddress: string,
    getTypedDataLuDto: GetTypedDataLuDto,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/collection/${contractAddress}/transferOwnership/typedData`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: getTypedDataLuDto
    },
      options);
    }
  
/**
 * Get an intentional exception by httpCode and errorMessage to test alerts
 * @summary Get an intentional exception
 */
export const exceptionTestControllerGetException = (
    params: ExceptionTestControllerGetExceptionParams,
 options?: SecondParameter<typeof axiosInstance>,) => {
      return axiosInstance<void>(
      {url: `/api/v1/exception-test`, method: 'get',
        params
    },
      options);
    }
  
export type CustomHistoriesControllerCreateCustomHistoryResult = NonNullable<Awaited<ReturnType<typeof customHistoriesControllerCreateCustomHistory>>>
export type CustomHistoriesControllerUpdateCustomHistoryMetadataResult = NonNullable<Awaited<ReturnType<typeof customHistoriesControllerUpdateCustomHistoryMetadata>>>
export type CustomHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchemaResult = NonNullable<Awaited<ReturnType<typeof customHistoriesControllerGetCustomHistoryOfAuctionMetadataJSONSchema>>>
export type CustomHistoryControllerAddCustomHistoryTypeResult = NonNullable<Awaited<ReturnType<typeof customHistoryControllerAddCustomHistoryType>>>
export type SRRControllerGetSRRsResult = NonNullable<Awaited<ReturnType<typeof sRRControllerGetSRRs>>>
export type SRRControllerCreateSRRResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCreateSRR>>>
export type SRRControllerCreateSRRTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCreateSRRTypedData>>>
export type SRRControllerUpdateSRRResult = NonNullable<Awaited<ReturnType<typeof sRRControllerUpdateSRR>>>
export type SRRControllerUpdateSRRTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerUpdateSRRTypedData>>>
export type SRRControllerGetMetadataJSONByTokenIDResult = NonNullable<Awaited<ReturnType<typeof sRRControllerGetMetadataJSONByTokenID>>>
export type SRRControllerUpdateMetadataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerUpdateMetadata>>>
export type SRRControllerUpdateMetadataTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerUpdateMetadataTypedData>>>
export type SRRControllerGetMetadataJSONSchemaV1Result = NonNullable<Awaited<ReturnType<typeof sRRControllerGetMetadataJSONSchemaV1>>>
export type SRRControllerGetTransferMetadataJSONSchemaV1Result = NonNullable<Awaited<ReturnType<typeof sRRControllerGetTransferMetadataJSONSchemaV1>>>
export type SRRControllerGetMetadataHistoryResult = NonNullable<Awaited<ReturnType<typeof sRRControllerGetMetadataHistory>>>
export type SRRControllerConvertMetadataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerConvertMetadata>>>
export type SRRControllerApproveByCommitmentResult = NonNullable<Awaited<ReturnType<typeof sRRControllerApproveByCommitment>>>
export type SRRControllerCancelApprovedResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCancelApproved>>>
export type SRRControllerApproveByCommitmentTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerApproveByCommitmentTypedData>>>
export type SRRControllerCancelApprovedTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCancelApprovedTypedData>>>
export type SRRControllerTransferByRevealResult = NonNullable<Awaited<ReturnType<typeof sRRControllerTransferByReveal>>>
export type SRRControllerTransferFromWithProvenanceResult = NonNullable<Awaited<ReturnType<typeof sRRControllerTransferFromWithProvenance>>>
export type SRRControllerSafeTransferFromTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerSafeTransferFromTypedData>>>
export type SRRControllerCreateAndSendBatchResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCreateAndSendBatch>>>
export type SRRControllerCreateAndSendBatchTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCreateAndSendBatchTypedData>>>
export type SRRControllerGetBatchResult = NonNullable<Awaited<ReturnType<typeof sRRControllerGetBatch>>>
export type SRRControllerPauseGeneralizedBulkQueueResult = NonNullable<Awaited<ReturnType<typeof sRRControllerPauseGeneralizedBulkQueue>>>
export type SRRControllerResumeGeneralizedBulkQueueResult = NonNullable<Awaited<ReturnType<typeof sRRControllerResumeGeneralizedBulkQueue>>>
export type SRRControllerAddHistoryTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerAddHistoryTypedData>>>
export type SRRControllerAddHistoryResult = NonNullable<Awaited<ReturnType<typeof sRRControllerAddHistory>>>
export type SRRControllerSetLockExternalTransferResult = NonNullable<Awaited<ReturnType<typeof sRRControllerSetLockExternalTransfer>>>
export type SRRControllerSetLockExternalTransferTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerSetLockExternalTransferTypedData>>>
export type SRRControllerCheckERC2981RoyaltyResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCheckERC2981Royalty>>>
export type SRRControllerCreateCollectionSRRResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCreateCollectionSRR>>>
export type SRRControllerCreateCollectionSRRTypeDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCreateCollectionSRRTypeData>>>
export type SRRControllerGetCollectionMetadataJSONByTokenIDResult = NonNullable<Awaited<ReturnType<typeof sRRControllerGetCollectionMetadataJSONByTokenID>>>
export type SRRControllerCollectionSRRMetadataUpdateResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionSRRMetadataUpdate>>>
export type SRRControllerCollectionGetMetadataHistoryResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionGetMetadataHistory>>>
export type SRRControllerCollectionUpdateSRRResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionUpdateSRR>>>
export type SRRControllerCollectionUpdateSRRTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionUpdateSRRTypedData>>>
export type SRRControllerCollectionSRRMetadataUpdateTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionSRRMetadataUpdateTypedData>>>
export type SRRControllerCollectionApproveByCommitmentResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionApproveByCommitment>>>
export type SRRControllerCollectionCancelApprovedResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionCancelApproved>>>
export type SRRControllerCollectionApproveByCommitmentTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionApproveByCommitmentTypedData>>>
export type SRRControllerCollectionCancelApprovedTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionCancelApprovedTypedData>>>
export type SRRControllerCollectionTransferByRevealResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionTransferByReveal>>>
export type SRRControllerCollectionTransferFromWithProvenanceResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionTransferFromWithProvenance>>>
export type SRRControllerCollectionTransferFromTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionTransferFromTypedData>>>
export type SRRControllerCollectionSetLockExternalTransferResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionSetLockExternalTransfer>>>
export type SRRControllerCollectionSetLockExternalTransferTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionSetLockExternalTransferTypedData>>>
export type SRRControllerCollectionAddHistoryTypedDataResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionAddHistoryTypedData>>>
export type SRRControllerCollectionAddHistoryResult = NonNullable<Awaited<ReturnType<typeof sRRControllerCollectionAddHistory>>>
export type LicensedUserControllerCreateLicensedUserWalletResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerCreateLicensedUserWallet>>>
export type LicensedUserControllerGetLicensedUserWalletsResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerGetLicensedUserWallets>>>
export type LicensedUserControllerSetEnglishNameResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerSetEnglishName>>>
export type LicensedUserControllerSetOriginalNameResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerSetOriginalName>>>
export type LicensedUserControllerAddOwnersResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerAddOwners>>>
export type LicensedUserControllerRemoveOwnersResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerRemoveOwners>>>
export type LicensedUserControllerGetCollectionsByLUWContractAddressResult = NonNullable<Awaited<ReturnType<typeof licensedUserControllerGetCollectionsByLUWContractAddress>>>
export type HealthControllerHealthCheckResult = NonNullable<Awaited<ReturnType<typeof healthControllerHealthCheck>>>
export type AppInfoControllerGetVersionResult = NonNullable<Awaited<ReturnType<typeof appInfoControllerGetVersion>>>
export type AppInfoControllerGetGasInfoResult = NonNullable<Awaited<ReturnType<typeof appInfoControllerGetGasInfo>>>
export type TxControllerGetTxResult = NonNullable<Awaited<ReturnType<typeof txControllerGetTx>>>
export type TxControllerSetConfigResult = NonNullable<Awaited<ReturnType<typeof txControllerSetConfig>>>
export type TxControllerGetConfigResult = NonNullable<Awaited<ReturnType<typeof txControllerGetConfig>>>
export type TxControllerSetOverrideGasPriceResult = NonNullable<Awaited<ReturnType<typeof txControllerSetOverrideGasPrice>>>
export type TxControllerResendResult = NonNullable<Awaited<ReturnType<typeof txControllerResend>>>
export type MetadataControllerGetMetadataJSONByHashResult = NonNullable<Awaited<ReturnType<typeof metadataControllerGetMetadataJSONByHash>>>
export type SchemaControllerGetJSONSchemaResult = NonNullable<Awaited<ReturnType<typeof schemaControllerGetJSONSchema>>>
export type CertAttachmentFileControllerGeneratetFileSignedUrlsV2Result = NonNullable<Awaited<ReturnType<typeof certAttachmentFileControllerGeneratetFileSignedUrlsV2>>>
export type CertAttachmentFileControllerGetFileMetadataV2Result = NonNullable<Awaited<ReturnType<typeof certAttachmentFileControllerGetFileMetadataV2>>>
export type CertAttachmentFileControllerGenerateCertAttachmentFileSignedUrlsResult = NonNullable<Awaited<ReturnType<typeof certAttachmentFileControllerGenerateCertAttachmentFileSignedUrls>>>
export type CertAttachmentFileControllerGeneratetFileSignedUrlsByPathResult = NonNullable<Awaited<ReturnType<typeof certAttachmentFileControllerGeneratetFileSignedUrlsByPath>>>
export type CertAttachmentFileControllerGetFileMetadataResult = NonNullable<Awaited<ReturnType<typeof certAttachmentFileControllerGetFileMetadata>>>
export type CollectionControllerGetCollectionResult = NonNullable<Awaited<ReturnType<typeof collectionControllerGetCollection>>>
export type CollectionControllerCreateCollectionResult = NonNullable<Awaited<ReturnType<typeof collectionControllerCreateCollection>>>
export type CollectionControllerCreateCollectionTypedDataResult = NonNullable<Awaited<ReturnType<typeof collectionControllerCreateCollectionTypedData>>>
export type CollectionControllerTransferOwnershipResult = NonNullable<Awaited<ReturnType<typeof collectionControllerTransferOwnership>>>
export type CollectionControllerTransferOwnershipTypedDataResult = NonNullable<Awaited<ReturnType<typeof collectionControllerTransferOwnershipTypedData>>>
export type ExceptionTestControllerGetExceptionResult = NonNullable<Awaited<ReturnType<typeof exceptionTestControllerGetException>>>
